<!DOCTYPE html>
<html lang="zh">

<head>
    <meta charset="UTF-8">
    <meta
      name="viewport"
      content="width=device-width, initial-scale=1.0"
    >
    <title>Document</title>
</head>

<body>
    <script>
        class Parent {
            constructor(name) {
                this.name = name;
            }

            greet() {
                console.log('greed:', this.name);
            }
        }

        // 继承默认继承父类构造函数和静态属性以外的属性方法。如果要继承构造函数内部的属性（非构造函数本身）则需调用super方法。
        class Child extends Parent {
            constructor(name, age) {
                // ! 如果子类中存在构造函数，则需要在使用“this”之前首先调用 super()。
                // console.log(this); // ! 子类任何一处地方，super之前的语句无法访问this属性，包括introduce。react中，仅构造函数内部。
                super(name);  // 调用父类的构造函数，同时相应的参数也必须传过去，react中不传props，则空有父类的构造函数，但没有参数传过去。
                // 如果使用父类的一些构造方法，则可能无法获取参数。
                this.age = age;
            }

            introduce() {
                console.log(this.name, this.age);
            }
        }

        const child = new Child('John', 10);
        child.introduce();
        child.greet();

        // 继承的本质就是原型链的延伸。
        // ! 该方法构造函数还是parent，而child还是自身构造函数child，而且比child要多一层，即实例。
        function Son(params) {

        }
        // 继承一个parent的实例，沿用Parent的构造函数，
        Son.prototype = new Parent();
        console.log(Child.prototype, child.__proto__)
    </script>
</body>

</html>