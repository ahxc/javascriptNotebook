<!DOCTYPE html>
<html lang="zh">

<head>
    <meta charset="UTF-8">
    <meta
        name="viewport"
        content="width=device-width, initial-scale=1.0"
    >
    <title>代码题算法题</title>
</head>

<style>
    .box1 {
        background-color: red;
        width: 100px;
        height: 100px;
    }

    .box2 {
        background-color: lightblue;
        width: 50px;
        height: 50px;
    }
</style>

<body>
    <div class="box1">
        <div class="box2"></div>
    </div>

    <script>
        /* 
        判断一个字符串是否为对称数
        例：'123321'
         */
        function symmetry(str = '') {
            return str === str.split('').reverse().join('');
        }
        // print();

        /* 
        使用 setTimeout 实现 setInterval，
        注意：setTimeout执行完毕不使用变量保存会自动清空不需手动清空。setInterval也没有立即执行属性但会立即执行一次。
        */
        function mySetInterval(fn, time) {
            fn()
            setTimeout(() => {
                mySetInterval(fn, time)
            }, time)
        }
        // 原生都将开辟新空间，所以i始终打印1
        // mySetInterval(() => {
        //     let i = 0;
        //     i += 1;
        //     console.log(i);
        // }, 1000);

        /* 
        查找第K个最大元素
        注意去重版和非去重要求，通常不用去重。去掉new set即可
         */
        function findKLargest(array, k) {
            const list = Array.from(new Set(array)).sort((a, b) => a - b);
            return list[k - 1];
        }

        /* 
        抚平嵌套数组
         */
        function flat(arr = [], n = 0) {
            let list = []
            arr.forEach((el) => {
                if (Array.isArray(el) && n > 0) {
                    list = list.concat(flat(el, n - 1))
                }
                else {
                    list.push(el)
                }
            })
            return list
        }
        // console.log(flat([1, 2, 3, [4, 5, 6], [7, 8, [9, 10, 11], 12], [13, 14, 15]], 2))

        /* 
        数组排序，先排数字，再排字母
        例子：["B3", "D2", "F1", "A9", "D12", "A2", "C1", "Z0", "B1"] 
        */
        function sortData(data) {
            return data.sort((a, b) => {
                const [matchA, codeA, numA] = a.match(/([A-Z])(\d+)/);
                const [matchB, codeB, numB] = b.match(/([A-Z])(\d+)/);

                const numComparison = parseInt(numA) - parseInt(numB);
                if (numComparison !== 0) {
                    return numComparison;
                }
                else {
                    // 比较字母顺序，升序返回-1，降序返回1，相同字母返回0。
                    return codeA.localeCompare(codeB);
                }
            });
        }
        const data = ["B3", "D2", "F1", "A9", "D12", "A2", "C1", "Z0", "B1"];
        // console.log(sortData(data))

        /* 
        使用promise每隔一秒输出123
        */
        async function print(time) {
            // 基础原理
            // for (let i = 1; i < 4; i++) {
            //     setTimeout(() => {
            //         console.log(i);
            //     }, i * 1000);
            // }

            // promise 改造
            for (let i = 1; i < 4; i++) {
                await pro(i); // await也要加上。
            }

            function pro(interval) {
                return new Promise((resolve, reject) => {
                    setTimeout(() => {
                        console.log(interval);
                        resolve(interval); // 无此句会一秒后同时打印出123，因为await 等不到返回结果，for循环会立即执行。
                    }, 1000);
                });
            }
        }
        // print()

        /* 
        盒子内部点击打印false，外部点击打印true，
        如果是vue的话使用.self修饰符，只有点击事件本身才会触发
         */
        var box1 = document.getElementsByClassName('box1')[0];
        box1.addEventListener('click', function (event) {
            var isInside = event.target === box1; // 冒泡的时候触发事件检查点击的是否是div元素本身
            console.log(isInside ? '内部点击' : '外部点击');
        });

        /* 
        深拷贝
         */
        function deepClone(data) {
            return JSON.parse(JSON.stringify(data));
        }

        const i = [
            { id: '1', value: '1' },
            { id: '2', value: '2' },
            { id: '3', value: '3' },
            { id: '1-1', value: '1-1', pid: '1' },
            { id: '2-1', value: '2-1', pid: '2' },
            { id: '3-1', value: '3-1', pid: '3' },
            { id: '3-1-1', value: '3-1-1', pid: '3-1' },
        ];
        // 把含树结构的array数据转换为children层级形式的array返回
        function list2tree(list = [], id = 'id', pid = 'pid') {
            // 深拷贝
            const d_list = deepClone(list);

            // key，value字典
            const dic = {};
            for (const i of d_list) {
                dic[i[id]] = i;
            }

            // 树
            const tree = [];
            let index = 0;
            for (const i of d_list) {
                const p = dic[i[pid]];
                if (p) {
                    p.children = p.children ? [...p.children, i] : [i];
                    i.level = (p.level || 0) + 1;
                }
                else {
                    i.level = 0;
                    tree.push(i);
                }
            }
            return deepClone(tree);
        }

        // 组件
        const com = {}
        // 根据上述list2tree生成的数据返回树组件
        function loopComponent(list) {
            for (const i of list) {
                if (Array.isArray(i.children)) {
                    loopComponent(i.children)
                }
                return com
            }
        }

        // 给数字字符串添加千分位，注意小数点。
        // 原生实现 number.toLocaleString() // '123,456.789'
        function addThousandSeparator(num) {
            var numParts = String(num).split(".");
            numParts[0] = numParts[0].replace(/\B(?=(\d{3})+(?!\d))/g, ","); // 找到千分位
            return numParts.join(".");
        }
        // console.log(addThousandSeparator('6666666.6666666666'))
        function addThousandSeparator2(num) {
            const numParts = String(num).split(".");
            const str = numParts[0]
            let res = ''
            let count = 0
            for (let index = str.length - 1; index >= 0; index--) {
                let element = str[index];
                res = element + res
                count += 1
                if (count === 3 && index > 0) {
                    res = ',' + res
                    count = 0
                }
            }
            return res + '.' + numParts[1]
        }
        // console.log(addThousandSeparator2('6666666666.6666666666'))

        /* 
        json扁平化
        思路：数组扁平化一致，递归加融合
         */
        let json = {
            name: 'John',
            age: 30,
            address: {
                city: 'New York',
                state: 'NY',
                zip: '10001',
                addressPlus: {
                    city: 'new london'
                }
            },
            hobbies: ['reading', 'traveling', 'music', ['test', 'test2', ['test3']]]
        };
        function flattenJSON(obj = {}, prefix = '') {
            let result = {}
            for (const key of Object.keys(obj)) {
                const newPrefix = prefix ? prefix + '_' + key : key
                if (typeof obj[key] === 'object' && obj !== null) {
                    result = Object.assign(result, flattenJSON(obj[key], newPrefix))
                }
                else {
                    result[newPrefix] = obj[key]
                }
            }
            return result
        }
        // console.log(flattenJSON(json))

        /* 
        函数柯里化 实现
        (a,b,c)=>a+b+c
         */
        function curry(a) {
            return function (b) {
                return function (c) {
                    return a + b + c
                }
            }
        }
        // console.log(curry(1)(2)(3))

        /* 
        rgb转hex
        思路：toString(16)和填充前缀0
        三原色转十六进制颜色代码，如 255,255,255 => #ffffff
        */
        function num2hex(n) {
            return n.toString(16).padStart(2, '0')
        }
        function rgb2hex(r, g, b) {
            return '#' + num2hex(r) + num2hex(g) + num2hex(b)
        }
        // console.log(rgb2hex(16, 16, 16), parseInt('ff', 16)) //ff === 255

        // 平方根 sqrt，返回向下取整的整数
        // 思路二分法，两端靠拢
        function mySqrt(x) {
            // 整数x的平方根一定是在1到x的范围内，采用二分法
            let left = 1,
                right = x;
            while (left <= right) {
                let mid = left + ((right - left) >> 1); // 右移一位相当于除以2取中间值，这样写防止溢出。
                // 判断mid的平方是否小于或等于x，如果mid的平方小于x
                if (mid ** 2 <= x) {
                    // 判断(mid+1)的平方是否大于x，如果(mid+1)的平方大于x，那么mid就是x的平方根
                    if ((mid + 1) ** 2 > x) {
                        return mid;
                    }
                    // 如果mid的平方小于x并且(mid+1)的平方小于x，那么x的平方根比mid大，接下来搜索从mid+1到x的范围
                    left = mid + 1;
                }
                else {
                    // 如果mid的平方大于x，则x的平方根小于mid，接下来搜索1到mid-1的范围
                    right = mid - 1;
                }
            }
            // 如果输入参数是0，left等于1而right等于0，就直接返回0
            return 0;
        };
        // console.log(mySqrt(6))

        /* 
        for循环与var，let
        */
        for (var index = 0; index < 3; index++) {
            setTimeout(() => {
                // console.log(index)
            }, 0);
        }
        // 3 3 3，因为var已经加完，按事件循环机制再执行console。

        for (let index = 0; index < 3; index++) {
            setTimeout(() => {
                // console.log(index)
            }, 0);
        }
        // 0 1 2，块级作用域for循环参数index有闭包保护。他们都是经过延时后一同调用，因为时间循环机制。

        /* 
        this 指向问题
        */
        const fun = {
            count: 'ahxc',
            show: function () {
                console.log('show', this.count)
            }
        }
        const exc = fun.show
        // exc() // undefined ，对象是window
        // fun.show() // ahxc ，对象是fun

        var value = 100
        function fn() {
            this.value++;
            return this.value;
        }
        var obj = {
            value: 1,
            fn
        }
        function delay(fn, delay) {
            return new Promise((resolve) => {
                setTimeout(() => {
                    resolve(fn());
                }
                    , delay);
            })
        }
        async function run() {
            var value = 10;
            try {
                console.log(1)
                const pms1 = delay(fn, 100);
                const pms2 = delay(obj.fn, 200);
                const value1 = await pms1;
                const value2 = await pms2;
                const value3 = await delay(fn.bind(obj), 300);
                console.log(value1, value2, value3)
            }
            catch (err) {
                console.error(err);
            }
        }
        // 耗时 500，pms1 pms2 是同步调用后，在使用两个await干扰项。

        /* 
        空瓶换汽水，3个空瓶换一瓶汽水，喝完可以加入剩余空瓶继续换，
        剩到两个空瓶可以和老板借一个空瓶换汽水到时喝完还给老板。换句话说，剩两个空瓶后可换一瓶汽水。
        思路：如果n>3循环减去2（减三个加一个）可以算喝了一瓶，剩两个空瓶再喝一瓶
        */
        function bottle(n) {
            s = 0
            while (n >= 3) {
                n -= 2
                s += 1
            }
            if (n === 2) {
                s += 1
            }
            return s
        }
        // console.log(bottle(2))

        /* 
        n阶台阶问题，注意每次只能爬1和2阶台阶，n阶只能从n-1或n-2跳过来
        思路，所以n阶的跳法只能是n-1和n-2跳法的和，斐波那契数列去掉了0和1。0 1 1 2 3 5 8
        */
        function climbStairs(n) {
            if (n <= 2) return n
            let p = 1
            let q = 2
            for (let i = 3; i <= n; i++) {
                let temp = p
                p = q
                q = q + temp
            }
            return q
        }
        // console.log(climbStairs(2))

        /* 
        n阶台阶升级版，p，q是可以手动输入控制的，又有多少种解法，
        */
        function climbStairs(n, p, q) {

        }

        /* 
        验证有效ip地址
        思路：含 . ipv4 含:ipv6
        对于ipv4：一组0~255，没有0前缀，将每组化作整型再转回字符串，看是否等于自身，即可去掉0前缀和非法字符
        ipv6同理，0~ffff，a~f，注意ipv6可以有0前缀，所以转换十进制然后十六机制后的和自身都用0填充至4位即可。注意大小写，全部小写处理。
        */
        var validIPAddress = function (queryIP) {
            if (queryIP.includes('.')) {
                const list = queryIP.split('.')
                if (list.length !== 4) return 'Neither'
                for (const i of list) {
                    if (!checkip4(i)) {
                        return 'Neither'
                    }
                }
                return 'IPv4'
            }
            else {
                const list = queryIP.split(':')
                if (list.length !== 8) return 'Neither'
                for (const i of list) {
                    if (!checkip6(i)) {
                        return 'Neither'
                    }
                }
                return 'IPv6'
            }
        };

        function checkip4(str) {
            if (parseInt(str) > 255) {
                return false
            }
            // 如果是合法的转数字再转回去是不变的，有非法字符或前缀0或空串都不行，空串""''都为0
            if (String(parseInt(str)) !== str) {
                return false
            }
            return true
        }

        function checkip6(str) {
            if (str.length > 4) {
                return false
            }
            // 超出范围
            if (parseInt(str, 16) > parseInt('ffff', 16)) {
                return false
            }
            // ! 0dc8==dc8==DC8==dC8，统一转为小写，并用0补充空位；
            // 转为十进制然后回16进制排除非法字符如fGb2，g为非法字符，合理范围abcdef；
            if (parseInt(str, 16).toString(16).padStart(4, '0') !== str.padStart(4, '0').toLowerCase()) {
                return false
            }
            return true
        }
        // console.log(validIPAddress("2001:0db8:85a3:00000:0:8A2E:0370:7334"))

        /* 
        前k个高频词汇
        思路：用字典统计每个单词出现次数，然后根据次数排序字典即可，相同字数使用localeCompare字母单词排序即可。
        注意：如果是相同频率的单词，按照字典abc的顺序排序
        */
        function topKFrequent(params) {
            const dic = {}
            for (const i of words) {
                if (dic[i]) {
                    dic[i] += 1
                }
                else {
                    dic[i] = 1
                }
            }

            const list = Object.keys(dic).sort((a, b) => {
                if (dic[a] === dic[b]) {
                    return a.localeCompare(b) // 字母顺序
                }
                return dic[b] - dic[a]
            })
            return list.slice(0, k)
        }

        /* 
        反转句子
        hello word =》word hello
        注意首尾空格和空元素
         */
        function reverseWords(s) {
            const list = s.split(' ')
            return list.filter((item) => item).reverse().join(' ')
        };

        /* 
        重复子串
        思路：如果A连续子串能得出B，必有AAAABAAA，那么其重复子串A的长度不会超过ABA的长度。
        以此界限，暴力叠加A看包不包含B即可。
        重复子串A多少次能有B，注意A本身包含B算一次。没有B返回-1
        */
        function repeatedStringMatch(a, b) {
            const len = a.length * 2 + b.length
            let count = 1
            let temp = a
            while (temp.length <= len) {
                if (temp.includes(b)) {
                    return count
                }
                count += 1
                temp += a
            }
            return -1
        };

        /* 
        最长公共子串
        遍历每个元素，末端往元素靠拢暴力枚举
        注意：最优解可能在末尾，所以必须全部遍历完。
        */
        function commonSubStr(sub, main) {
            if (sub.length > main.length) {
                const temp = sub;
                sub = main;
                main = temp;
            }
            let length = 0;
            for (let i = 0; i < sub.length; i++) {
                let endIndex = sub.length;
                while (i < endIndex) {
                    const str = sub.slice(i, endIndex);
                    if (main.includes(str)) {
                        length = Math.max(length, str.length);
                        break;
                    } else {
                        endIndex -= 1;
                    }
                }
            }
            console.log(length);
        }

        /* 
        最长公共子串 动态规划升级版
        思路：利用二维数组，如果有匹配，则在左上角的基础上+1，左上角意味着有公共元素相交。形成一条递增对角线，
        保存这个对角线的最大值。
         */
        function commonSubStr(str1, str2) {
            // const zero = Array(str2.length + 1).fill([]); // 注意！不能这样写，因为fill都是同一个对象，会有深度影响，深拷贝也没用。
            // 只能新增一个for循环
            const sets = Array(str1.length + 1);
            for (let i = 0; i < sets.length; i++) {
                sets[i] = Array(str2.length + 1).fill(0)
            }

            let length = 0;
            for (let str1Index = 1; str1Index <= str1.length; str1Index++) {
                for (let str2Index = 1; str2Index <= str2.length; str2Index++) {
                    if (str1[str1Index - 1] === str2[str2Index - 1]) {
                        sets[str1Index][str2Index] =
                            sets[str1Index - 1][str2Index - 1] + 1;
                        length = Math.max(sets[str1Index][str2Index], length);
                    }
                }
            }
            console.log(length);
        }

        /* 
        十进制的反码，
        思路：toString(2)，即转二进制后1取0,0取1，然后转为十进制
        */
        var bitwiseComplement = function (n) {
            let N2 = n.toString(2)
            let str = ''
            for (let i = 0; i < N2.length; i++) {
                if (N2[i] === '0') {
                    str += '1'
                }
                else {
                    str += '0'
                }
            }
            return parseInt(str, 2)
        };

        /* 
        接雨水
        思路：将每个单位视作一个木桶，能接多少水取决于他的短板。用最小短板-自身高度即可这个单位头顶有多少水
        计算左边和右边的最大短板超时
        */
        var trap = function (height) {
            const list = [] // 每个单位的最小短板集合
            let count = 0
            for (let i = 0; i < height.length; i++) {
                const left = Math.max(...height.slice(0, i), 0)
                const right = Math.max(...height.slice(i + 1), 0)
                list.push(left < right ? left : right)
            }
            for (let i = 0; i < height.length; i++) {
                count += Math.max(list[i] - height[i], 0)
            }

            return count
        }

        /*
        接雨水
        Math.max超时改造版
        用最大自增序列来分别计算左右短板替代max方法，空间复杂多两个递增序列  1 1 2 0 3 2...=》1 1 2 2 3 3 ...
        最大自增序列，即遇到新的最大值设为后续自增标准，以2为例，2的左最大短板是1是2无影响，装不了水。所以为2对齐后续。
        右最大短板按相反方向同时来一次即可
        */
        var trapPlus = function (height) {
            let count = 0

            const maxLeft = []
            const maxRight = []

            // 最大递增序列左右两个方向
            for (let i = 0; i < height.length; i++) {
                maxLeft.push(Math.max(maxLeft[i - 1] || 0, height[i]))
                maxRight.push(Math.max(maxRight[i - 1] || 0, height[height.length - 1 - i]))
            }

            for (let i = 0; i < height.length; i++) {
                const min = Math.min(maxLeft[i], maxRight[height.length - 1 - i])
                count += Math.max(min - height[i], 0)
            }
            return count
        }

        /*
       接雨水
       双指针版升级版，将最大递增子数列合并。
       思路：如果单位的左短板小于右短板，那么他可以装最多左短板-自身高度的水，注意这时左指针需要右移，而右指针不变！
       反之，单位的右短板小于左短板，那么他可以装最多右短板-自身高度的水，
       如若相等，则无所谓左右，拿其中一个短板-自身高度的水
       在移动双指针时，同步更新最大短板，注意不能遗漏指针合并时还一次计算
       本质是最大递增虚列的左右合并。
       */
        var trap = function (height) {
            let count = 0
            let maxLeft = 0 // 最大短板
            let maxRight = 0
            let leftIndex = 0
            let rightIndex = height.length - 1
            while (leftIndex <= rightIndex) {
                maxLeft = Math.max(maxLeft, height[leftIndex])
                maxRight = Math.max(maxRight, height[rightIndex])
                if (maxLeft < maxRight) {
                    count += maxLeft - height[leftIndex]
                    leftIndex += 1
                }
                else {
                    count += maxRight - height[rightIndex]
                    rightIndex -= 1
                }
            }
            return count
        }

        /* 
        1764.连接数组 groups（二维数组），nums（一维数组）
        能否在nums中找到groups所有子数组
        这些子数组顺序和groups子数组出现顺序一致，且不想交，满足true，反之false
        思路：遍历groups，groups和nums都用连接符逗号转字符串，通过indexOf计算索引。有一个找不到等于-1则false
        找到后利用slice切片切除之前所有部分，防止下一个找到后与上一个相交。
        注意：如果找到了，那么这个子串（子数组）的左边只存在两种情况：1.开头就找到了，所以左边没有元素undefined，中间找到了，那么左边应该是连接符','，下次匹配这个连接符需要切掉
        防止特殊情况：[[2,1]] [12,1]，[2,1]，这个找到后左边是1，应该是false
        */
        var canChoose = function (groups, nums) {
            nums = nums.join(',')
            for (const i of groups) {
                const sub = i.join(',')
                const index = nums.indexOf(sub)
                if (index === -1 || nums[index - 1] && nums[index - 1] !== ',') {
                    return false
                }
                nums = nums.slice(index + sub.length + 1)
            }
            return true
        };

        /*
        找座位，【没有经过机试】
        给定一组数据1000101001,1有人，0无人，在满足010，10,01的情况下，最多能坐多少人
        遍历字符串，如果为0，满足左边：undefined或0的情况下，则坐人。
        注意：计算过的位置要坐人改变状态，0000000000
        */
        function findPosition(n) {
            let count = 0
            n = n.split('')
            for (let i = 0; i < n.length; i++) {
                if (n[i] === '0') {
                    const left = n[i - 1] === '0' || i === 0
                    const right = n[i + 1] === '0' || i === n.length - 1
                    if (left && right) {
                        count += 1
                        // 坐上人
                        n.splice(i, 1, '1')
                    }
                }
            }
            return count
        }
        // console.log(findPosition('00100000001010'))

        /*
        最长瑕疵元音子串，暴力破解【没有经过机试】
        以aeiou开始和结尾的字符串为元音字符串，如a，aa，aeiou，abo
        瑕疵度flaw为元音字符串中有多少个非元音字母，a，aa瑕疵度为0，abo为1
        找出满足指定瑕疵度的最大元音子串。返回他的长度
        思路：和最长公共子串暴力解法类似，双指针遍历，末端往左指针靠拢，找到最长的且满足指定瑕疵即可。
        注意：与最长公共子串相同，答案可能在末尾，所以需要遍历完去最大值，
        */
        function aeiou(str, n) {
            const yuan = 'aeiou'
            let count = 0
            let length = 0
            for (let startIndex = 0; startIndex < str.length; startIndex++) {
                let endIndex = str.length - 1
                while (startIndex <= endIndex) {
                    const left = yuan.includes(str[startIndex])
                    const right = yuan.includes(str[endIndex])
                    const condition = n === computeFlaw(str.slice(startIndex, endIndex + 1))
                    if (left && right && condition) {
                        length = Math.max(str.slice(startIndex, endIndex + 1).length, length)
                    }
                    endIndex--
                }
            }
            return length
        }
        // 计算瑕疵度
        function computeFlaw(str) {
            const yuan = 'aeiou'
            let count = 0
            for (let index = 0; index < str.length; index++) {
                if (!yuan.includes(str[index])) {
                    count += 1
                }
            }
            return count
        }
        // console.log(aeiou('aabeebuu', 1))

        /* 
        掌握单词个数，暴力破解【没有经过机试】
        n个单词组成的str，每个单词能否用char拆开组合，如 abc  abstract，abc可以组合，
        char还包括?可以抵消一一个字母，万能字母。如abstra?t ，？抵消c
        输出多少个单词可以这样掌握。
        思路：可以统计每个单词的字母出现次数，和char对比。如果遇到单词字母次数大于>char字母次数，拿万能字母?抵消
        每个单词匹配都是重新开始，不消耗次数，但每次匹配char的字母只能匹配一次，包括万能字符。
        满足次数相等的计入掌握数
        */
        function takeWords(str, char) {
            const list = str.split(',')
            const dicChar = codeNums(char)
            dicChar['question'] = dicChar['question'] || 0
            let count = []
            for (let index = 0; index < list.length; index++) {
                const element = list[index];
                const dicWord = codeNums(element)
                let temp = dicChar['question'] // 记录初始问号数值下次匹配。
                let flag = true
                for (const i of Object.keys(dicWord)) {
                    if (dicWord[i] > (dicChar[i] || 0) + temp) {
                        flag = false
                        break
                    }
                    temp = Math.max(temp - dicWord[i] + (dicChar[i] || 0), 0)
                    console.log(dicWord[i], temp)
                }
                if (flag) {
                    count.push(element)
                }
            }
            return count
        }
        // 统计字母次数字典
        function codeNums(code) {
            const dic = {}
            for (let index = 0; index < code.length; index++) {
                const element = code[index];
                if (element === '?') {
                    dic["question"] = (dic["question"] || 0) + 1
                    continue
                }
                dic[element] = dic[element] ? dic[element] + 1 : 1
            }
            return dic
        }
        // console.log(takeWords('hello,world,cloud', 'welldonehohneyr'))

        /* 
        判断子序列
        判断一个字符串是否是另一个字符串的子序列，不要求连续，但顺序要保持一致，如 ace   asdfcwere。
        acb aewrbsdfec，则不行，因为b在c后面
        思路：暴力遍历，判断s中每个字符是否存在于t，如果存在，更新t开始搜索的索引后移避免顺序错误。
        这里可以用indexOf替代内层for循环。
        */
        var isSubsequence = function (s, t) {
            if (s.length > t.length) return false
            if (s.length === 0) return true
            let start = 0 // 开始搜索的位置，包含。
            for (let i = 0; i < s.length; i++) {
                const index = t.indexOf(s[i], start)
                if (index === -1) {
                    return false
                }
                start = index + 1
            }
            return true
        };

        /*
        找朋友，暴力遍历【没有经过机试】
        同学i往右看，有比他高的(第一个)则是好朋友，记录好朋友的索引位置。返回
        */
        function findFriends(str) {
            const list = str.split(',')
            count = Array(list.length).fill(0)
            for (let index = 0; index < list.length; index++) {
                const element = parseInt(list[index]);
                for (let indexf = index + 1; indexf < list.length; indexf++) {
                    const frind = parseInt(list[indexf]);
                    if (frind > element) {
                        count[index] = indexf
                        break
                    }
                }
            }
            return count
        }
        // console.log(findFriends('100,2,234,2123,23534,22,4432,543'))

        /* 
        电脑感染时间【未经过机试】
        给定一组二维数组，每子数组表示 电脑2 到 电脑1 感染时间1，最后一行2表示电脑病毒位置
        求病毒感染所有电脑所需的时间，感染同步进行，存在电脑不被感染即未连接网络，返回-1
        4 // 电脑数
        3 // 链接数
        2 1 1
        2 3 1
        3 4 1
        2
        答案为2 因为2-3花费1 3-4 花费1
        思路：1.要感染所有电脑，最少链接情况是一条直线，那么连接数应该等于电脑数-1 1-2-3-4
        但可能存在环，即 1-2-3  1-3这时连接数不可靠
        2.最长公共子串同样的道理，但横坐标和纵坐标相等，轴对称，如果动态规划左上角为0，意味着是存在独立链接。
        3.如果左上角为1，但自身为0，意味着靠近电脑顺序但没有连接
        */
        // function computerVirus(n, l, list, m) {
        //     if (l < n - 1) return -1
        //     // 格式化初始数据
        //     const net = list.split(',')
        //     for (let index = 0; index < net.length; index++) {
        //         net[index] = net[index].split(' ')
        //     }
        //     // 建立二维数组
        //     const sets = Array(n).fill([])
        //     for (let index = 0; index < sets.length; index++) {
        //         sets[index] = Array(n).fill(0);
        //     }
        //     // 画规划，net从1开始
        //     for (let index = 0; index < net.length; index++) {
        //         const element = net[index];
        //         const [a, b, t] = element
        //         sets[a - 1][b - 1] = t
        //         sets[b - 1][a - 1] = t // 轴对称
        //     }
        //     console.log(sets, net)
        //     // 计算时间和 -1
        //     const maxTime = 0
        //     for (let zindex = 0; zindex < sets.length; zindex++) {
        //         const element = sets[zindex];
        //         let zero = 0 // 这一行全为0
        //         // for (let xindex = 0; xindex < array.length; xindex++) {
        //         //     if (zindex !== 0 && xindex !== 0) {
        //         //         if (sets[zindex][xindex] > 0) {

        //         //         }
        //         //     }
        //         //     else {

        //         //     }
        //         // }
        //     }
        //     return maxTime
        // }
        // computerVirus(4, 3, '2 1 1,2 3 1,3 4 1', 2)
        function computerVirus(n, l, list, m) {
            // 格式化初始数据
            const net = list.split(',')
            for (let index = 0; index < net.length; index++) {
                net[index] = net[index].split(' ')
            }
            // 记录已感染的电脑，防止a感染b, b感染a 死循环。
            const dic = {}
            for (let index = 0; index < net.length; index++) {
                const element = net[index];
                const [a, b, t] = element
                // 找到病毒源，递归感染。
                if (a === m || b === m) {
                    dic[a]
                    virus(a, b, t)
                    break
                }
            }
        }
        function virus(a, b, t) {

        }
        // computerVirus(4, 3, '2 1 1,2 3 1,3 4 1', 2)

        /* 
        密码输入检测 【未经过机试】
        密码长度大于8，且必须包含1个大写字母，1个小写字母，1个数字，1个特殊字符
        注意：要拿退格后的字符串测试
        */
        function passwordCheck(str) {
            let password = []
            for (let index = 0; index < str.length; index++) {
                const element = str[index];
                if (element === '<') {
                    password.pop()
                    continue
                }
                else {
                    password.push(element)
                }
            }

            // 除字母数字以外的特殊字符，最好不要自己指定，因为可能会漏。
            const special = password.some((item) => {
                return !/[a-zA-Z0-9]/.test(item)
            })

            password = password.join('')

            // 数字
            let num = false
            if (/\d/.test(password)) {
                num = true
            }


            // 大小写
            const lower = password.toUpperCase() !== password // 有小写
            const upper = password.toLowerCase() === password // 有大写

            // 长度
            const length = password.length >= 8

            return `${password},${lower && upper && length && num && special}`
        }
        // console.log(passwordCheck('asdS#F<<<1<dfsaw#'))

        /*
        最小字符串 【未经过机试】
        最小字符串意为 按字母顺序的字符串 如 abcde是最小字符串，
        请只交换一对字母的位置 如 bcda acdb （排序后：abcd）变为最小的字符串。首字母排序次字母排序以此类推
        思路：先给字符串排序，找到第一位必是最小，然后找到原始字符串位置并交换，如果是相同字母，往后移指针判断
        注意：针队特殊用例如aaacdb aaabdc aaabcd，需要剔除掉重复的开头aaa，找到要交换位置的c。
        针对已经排序好的，等特殊情况需要特殊处理。
        */
        function minCode(str) {
            const newList = str.split('')
            const oldList = str.split('')
            newList.sort()

            for (let index = 0; index < newList.length; index++) {
                if (newList[index] === oldList[index]) {
                    continue
                }
                // 旧串种要被替换的字母
                const temp = oldList[index]

                // 新最小字母索引在旧串中的原始位置
                const sourceIndex = oldList.join('').indexOf(newList[index], index + 1)
                oldList.splice(index, 1, newList[index])
                oldList.splice(sourceIndex, 1, temp)
                return oldList.join('')
            }
            return oldList.join('')
        }
        // console.log(minCode('aaaaaaaccccbbbbb'))

        /*
        查找接口成功率最优时间段【未经过机试】
                     0 1 2   3 4 5 6
        给定一组数组 [0,2,100,0,2,2,5] 每个数值表示单位时间内接口失败的次数，
        给定一个容忍率minAverageLost，计算数组平均值小于minaveragelost的区间，比如2有
        0-1,3-5，这些区间平均值小于平均值。返回这些区间
        思路：1.建立一个list统计sum[i]前的总失败率，这样区间sum[j]到sum[i]的失败率等于 总sum[i]-总sum[j-1] 如 [0,2,102,102,104,106]
        2.然后双端暴力遍历，计算存在多少个区间，每个区间是否满足平均值小于minaveragelost，或者判断区间总失败率是否大于minaveragelost*区间长度。
        注意：1.注意题意，只计算区间，单个元素不计入返回。和单个元素也计入区间有区别。满足条件的，区间内的单个元素需要排除，区间外的单独输出。如
        2 0,2,100,0,2,2,5,2,5 倒数第二个是可以单独作为区间输出
        2.区间内存在多个子区间满足条件，取最大区间，如3-4 3-6，右端遍历到6满足条件可以直接跳出当层循环不用计算3-4
        3-6 4-6左端遍历也应该取最大区间，可以设值一个变量 最大区间右索引，如果有该值，且左索引小于该值，则跳过当前循环，意味着找到了满足条件的最大区间。
        */
        function computeAverageLost(minAverageLost, str) {
            const list = str.split(',')

            const sum = Array(list.length).fill(0)
            for (let index = 0; index < list.length; index++) {
                sum[index] = parseInt(sum[index - 1] || 0) + parseInt(list[index]);
            }

            const count = []
            let maxRightIndex = -1
            for (let leftIndex = 0; leftIndex < list.length; leftIndex++) {
                // 左边开始的缩减的子区间都可以不再计算。
                if (maxRightIndex >= 0 && leftIndex <= maxRightIndex) {
                    leftIndex = maxRightIndex
                    continue
                }
                for (let rightIndex = list.length - 1; leftIndex <= rightIndex; rightIndex--) {
                    let avarage = (sum[rightIndex] - (sum[leftIndex - 1] || 0)) / (rightIndex - leftIndex + 1)
                    if (avarage <= minAverageLost) {
                        count.push(`${leftIndex === rightIndex ? leftIndex + '' : leftIndex + '-' + rightIndex}`)
                        maxRightIndex = rightIndex
                        // 右边开始缩减的子区间都可以不用在计算。
                        break
                    }
                }
            }
            return count.join(' ')
        }
        // console.log(computeAverageLost(2, '0,0,100,2,2,99,0,2'))

        /*
        分割平衡字符串
        给定一个均衡字符串只包含两种字符xy，且xy个数相等 xyyxyxxxyy 可分割为 xy yx yx xxyy 4
        请尽可能分割成多个连续子串，使得每个子串亦是均衡字符串，返回最大均衡字符串个数。
        思路：建立一个平衡度0，一次遍历遇到x平衡度+1，遇到y-1抵消平衡度
        平衡度为0表示达到了最小平衡，计入一次子串，类似括号匹配。
        */
        var balancedStringSplit = function (s) {
            let count = 0
            let blance = 0
            for (let i = 0; i < s.length; i++) {
                if (s[i] === 'L') {
                    blance += 1
                }
                else {
                    blance -= 1
                }
                if (blance === 0) {
                    count += 1
                }
            }
            return count
        };

        /*
        单位时间内通过车辆最多颜色数量
        每一秒通过一两车，[0,1,1,2]4秒，共3种车，0,1,2
        给定一个时间n秒，计算n秒内出现颜色种类最多的车能有多少，
        思路：暴力遍历，就是一个时间划窗[left,...,right]，从头划窗，窗内颜色种内最多。
        加入【同向双指针】模拟划窗，即划窗右端为开始指针，紧跟着左端指针，右端划过一个元素，左端需要跟上。
        如：3秒内，滑到1,1,1时，0被左指针指着，应该减1。能将时间复杂度o(length*(n+m))=>o(length*n)
        */
        function countColorCar(str, n) {
            const list = str.split(' ')
            let maxCount = 0
            // 存储 0 1 2 车出现次数
            const count = Array(3).fill(0)
            let leftIndex = 0
            for (let rightIndex = 0; rightIndex < list.length; rightIndex++) {
                count[list[rightIndex]] += 1
                // 划窗又划过来了一个元素，右指针减去左指针长度大于n，等于n因为刚好初始化划过第一个一个元素不会触发下面代码
                while (rightIndex - leftIndex >= n) {
                    // 对齐
                    // 减去划窗略过的元素的次数
                    count[list[leftIndex]] -= 1
                    leftIndex += 1
                }
                maxCount = Math.max(maxCount, ...count)
            }
            return maxCount
        }
        // console.log(countColorCar('0 0 0 0 0', 0))

        /*
        积分奖励【未通过机试】
        有n个任务同时等待处理，处理一个任务花费时间1，同一时间只能处理一个任务，可获得积分奖励b，每个任务有时间限制a
        给你一个固定实现m，如何在m内获得最大积分。
        下面任务等候时限都是1，所以给你无论多少时间m，你都只能做最大积分的任务5，因为其他都会超时
        4个任务
        3秒时间
        1 2：1秒超时，2积分奖励
        1 3 
        1 4 
        1 5
        思路：1.分数最高的最有优先级，所以按照分数由高到低排列，
        2.时限最低的最有优先级，所以再按照由低到高排列
        3.遇到时限大于0，且m还有剩余，加入最大积分，然后后面大于等于该时限的时限全部1，直到0不计入计算。
        因为根据逆过程，你可以选择高时限的再选择低时限的。如 2 6,1 5。如果m为2，我可以选择6，再5，m用尽最大积分11，这是逆过程。
        注意：3,4步做完不需要重新排序，因为最大的积分已经被取走，顺序也是排好的。
        */
        function earnScore(n, m, str) {
            const list = str.split(',').map(item => {
                const l = item.split(' ')
                return [parseInt(l[0]), parseInt(l[1])]
            })
            list.sort((a, b) => {
                const [timeA, scoreA] = a
                const [timeB, scoreB] = b
                if (scoreA === scoreB) {
                    return timeA - timeB
                }
                return scoreB - scoreA
            })
            let maxScore = 0
            let currentTime = m
            for (let index = 0; index < list.length; index++) {
                let score = list[index][1]
                let time = list[index][0]
                if (time > 0 && currentTime > 0) {
                    maxScore += score
                    currentTime -= 1
                    for (let pindex = index + 1; pindex < list.length; pindex++) {
                        if (list[pindex][0] >= time) {
                            list[pindex][0] = Math.max(list[pindex][0] - 1, 0)
                        }
                    }
                }
                if (currentTime <= 0) {
                    return maxScore
                }
            }
            console.log(list)
            return maxScore
        }
        // console.log(earnScore(4, 9, '1 2,1 3,1 4,3 5,3 5,3 8,4 6,4 9,5 5'))

        /*
        最富裕的小家庭【未经过机试】
        一颗树上，父节点和所有直接子节点定义为一个小家庭，每个节点是个人资产，求解最富裕的小家庭。
        4
        100 200 300 500
        1 3
        1 2
        2 4
        最富裕小家庭700 2和4
        思路：1.遍历子节点序列(右)构建一个**字典**，将父子节点同时加入字典，id：当前节点（id，资产，pid）。
        2.然后根据字典构建成pid id的树，
        3. 然后递归，算每一个小家庭的资产总和，取最大值即可。
        注意：遍历的list可能不包含父节点，如上只能遍历出 3 2 4节点，父节点需要单独加入。
        */
        function countMaxWealth(n, str1, str2) {
            const dic = {}

            const wealths = str1.split(' ').map((item) => parseInt(item))
            const nodes = str2.split(',').map(item => {
                const l = item.split(' ')
                return [parseInt(l[0]), parseInt(l[1])]
            })

            for (let index = 0; index < nodes.length; index++) {
                const [pid, id] = nodes[index]
                if (!dic[id]) {
                    dic[id] = {
                        id,
                        pid,
                        wealth: wealths[id - 1],
                    }
                    // 父节点一起加入，父节点可能还有父节点，但此时无法获取。
                    if (!dic[pid]) {
                        dic[pid] = {
                            id: pid,
                            pid: '',
                            wealth: wealths[pid - 1]
                        }
                    }
                }
                else {
                    // 加入父节点的父节点id
                    if (!dic[id].pid) {
                        dic[id].pid = pid
                    }
                }
            }

            // 树
            const tree = []
            for (const key of Object.keys(dic)) {
                const pid = dic[key].pid
                // 根节点
                if (!pid) {
                    tree.push(dic[key])
                }
                else {
                    dic[pid].children = dic[pid].children ? [...dic[pid].children, dic[key]] : [dic[key]]
                }
            }


            return countWealth(tree)
        }

        // 计算当前家庭财富
        function countWealth(list) {
            let maxWealth = 0
            for (let index = 0; index < list.length; index++) {
                const node = list[index];
                if (node.children) {
                    // 注意使用reduce一定要保持初始值和callback的返回值数据结构一致。
                    let cw = node.children.reduce((pre, next) => {
                        return {
                            wealth: pre.wealth + next.wealth
                        }
                    }, { wealth: 0 })
                    maxWealth = Math.max(node.wealth + cw.wealth, countWealth(node.children, maxWealth))
                }
            }
            return maxWealth
        }
        // console.log(countMaxWealth(4, '100 200 300 500', '1 3,2 4,1 2'))

        /*
        孙悟空吃蟠桃
        给定一组蟠桃树 3 11 6 7 8，孙悟空1个小时内可以占用一棵树，一小时后才能离开，求解守卫过来前，孙悟空每小时内最小吃蟠桃个数k，这个k能吃完所有蟠桃。
        第二行守卫过来的时间 h 小时。不能吃完或其他问题返回k为 0
        思路：1.如果桃树数量大于守卫过来前的小时数，绝对吃不完。反之一定能吃完，因为速度可以取单颗桃树的最大桃子数量
        2.可以二分法，取最小速度low，最大速度桃子数量high，取他们中间值速度mid，如果这个速度mid经过计算每颗数时间总和能在守卫来之前吃完，说明速度可以更小，mid取代high
        反之吃不完，得加速度，mid取代low，以此迭代，求出最后速度。
        注意：守卫刚来，猴子刚吃完算一解，即time<=h。每颗树花费时间向上取整。
        */
        var minEatingSpeed = function (piles, h) {
            let high = Math.max(...piles)
            let low = 1
            while (low < high) {
                const mid = Math.floor((high - low) / 2) + low
                const time = computeTime(piles, mid)
                if (time <= h) {
                    high = mid
                }
                else {
                    low = mid + 1
                }
            }
            return high
        };

        function computeTime(piles, speed) {
            let time = 0
            for (const i of piles) {
                time += Math.ceil(i / speed)
            }
            return time
        }

        /*
        密码解密【未经过机试】
        给定一段密文s，他是经过字符转换而来
        转换规则：a-i由1-9表示，j-z由10*-26*表示，所以密文最终为：234210*23423*
        思路：1.可以按照栈的方式先进后出，遇到星号再取两个数字，遇到数字取当前数字即可。
        2.或者判断当前索引的后两个索引位置是不是星号。
        str.charCodeAt(index)，获取str指定索引位置的asc码。
        */
        function passtext(str) {
            let count = ''
            let index = 0
            while (index < str.length) {
                const element = str[index + 2];
                if (element && element === '*') {
                    count += num2code(parseInt(str.slice(index, index + 2)))
                    index += 3
                    continue
                }
                count += num2code(parseInt(str[index]))
                index += 1
            }
            return count
        }
        // 输入1-26转小写字母，遇到星号事先抛弃，小写字母从97a开始，122z结束
        function num2code(n) {
            console.log(n, String.fromCharCode(96 + n))
            return String.fromCharCode(96 + n)
        }
        // console.log(passtext('20*19*20*12345678926*'))

        /*
        找最小数字【未经过机试】中等
        给定一个数字m，求一个比m大的数字n，n的二进制1的个数等于m的二级制1的个数，返回这个最小n
        思路：1.m的二进制中，找到最低位的一个子串 01 将其反转 10，那么这个二进制数1的个数一定等于m的1个数，且满足最小条件。
        2.存在情况1000，做法是前面加一个0,01000 10000。也满足条件。
        3.存在情况110=>1010，加0再反转这不是最小的，需要末尾的0截取插入反转后的0末尾 1001。获得最小。
        4.用代码实现这个问题，就是去掉首位的1，和末尾的所有0，将所有0加到首位，首位再加10。
        注意：该题暴力会超时。str可能为1
        */
        function mn2code(m) {
            let str = m.toString(2)

            let count = ''
            for (let index = str.length - 1; index > 0; index--) {
                let t = str.slice(index - 1, index + 1)
                if (t && t === '01') {
                    count = str.split('')
                    count.splice(index - 1, 2, '10')
                    return count.join('')
                }
            }

            // 没找到01的情况
            str = str.slice(1)

            // 去掉末尾的0
            let zero = ''
            let main = ''
            for (let index = str.length - 1; index > 0; index--) {
                if (str[index] !== '0') {
                    main = str.slice(0, index + 1)
                    break
                }
                zero += '0'
            }
            return '10' + zero + main
        }
        // console.log(mn2code(parseInt(111000, 2)))

        /*
        运送货物【未经过机试】简单
        货物a重量利润： wa pa
        货物b重量利润： wb pb
        货车承载： wa*n +wb*m=t。固定
        求解货物最大利润，ab不能切割。
        思路，按公式暴力枚举wa(1-i-wt)只需一次遍历，剩余重量用用wb填补，如果满足总重量等于t则计算价格并更新最大值。
        途中如果wa*i>wt可以终止循环
        */

        /*
        部门人力分配【未经过机试】
        给定一组需求任务[3 5 3 4]，每个任务表示每个月需要多少人开发才能完。
        最多只能两个任务并行开发，且需求量不能大于每月人力数量，即这个月的不能留到下一个月必须开发完。
        求解M个月内完成所有需求开发的最小人力。上述m为3的话，答案为6，第一个月：3+3，5，4，三个月刚好开发完。
        【思路】：满足单调性，需要的人越多越有可能指定时间完成任务，采用二分法，
        对需求排序，取最后两个任务相加，或最后一个任务乘以2，这个是需要的最大人力，他满足任意两个任务拼接需求量不会超出人力。
        取最后一个任务为最小人力，他满足每个任务不能超出人力。
        */
        function requirements(m, list) {
            list.sort()
            let left = list[list.length - 1]
            let right = list[list.length - 1] * 2
            while (left < right) {
                let mid = Math.floor((right - left) / 2) + left
                // 超时，需要加人力
                if (compuRequirements(list, mid) > m) {
                    left = mid + 1
                }
                else {
                    right = mid
                }
            }
            return right
        }
        // 计算这个人力完成所有需求需要几个月
        // 这里使用双指针遍历，人力已经确定。不需要考虑最佳组合两个需求任务，直接判断首尾组合。
        function compuRequirements(list, r) {
            let month = 0
            let left = 0
            let right = list.length - 1
            while (left <= right) {
                // 最小和最大相加超过人力r，那么最大只能单独完成。
                if (list[left] + list[right] > r) {
                    month += 1
                    right -= 1
                }
                // 否则就一起完成
                else {
                    month += 1
                    left += 1
                    right -= 1
                }
            }
            return month
        }
        // console.log(requirements(3, [3, 5, 3, 4]),)

        /*
        考古学家：力扣47题 全排列2【中等】
        即求abc的排列，abc acb bac...
        如果有相同元素 如 aab aba baa需要排除重复元素的再次出现，如不能出现aab aab
        【思路】：和全排列1基本一致，不同的是，字符存在重复元素，需要剔除掉多个相同排列出现的重复现象。
        1.增加剔除条件：先将字符排序，根据索引，前一个元素是优先遍历的，如果等于自身如aab，且前一个元素被标记为使用过，
        那么这条路径是最先开始的路径 aab 可以加入结果，反之如果前一个元素没有被标记使用过，后面的路径用到了前面路径的相同元素，aab aab
        增加剔除条件，前一个元素存在且等于当前元素，且前一个元素没有被标记使用，那么这条路径需要终止。
        */
        const permuteUnique = (nums) => {
            const res = []
            const used = []

            nums.sort()

            function permute(path) {
                if (path.length === nums.length) {
                    res.push(path.slice())
                    return
                }

                for (let index = 0; index < nums.length; index++) {
                    if (used[index]) {
                        continue
                    }
                    // nums[index-1] && 错误，会多一些重复数据，因为nums[index-1]=0,0为假。用例：[0 0 0 1 9]
                    if (index - 1 >= 0 && nums[index - 1] === nums[index] && !used[index - 1]) {
                        continue
                    }

                    path.push(nums[index])
                    used[index] = true
                    permute(path)
                    path.pop()
                    used[index] = false
                }
            }

            permute([])
            return res
        };


        /*
        全排列1【中等】
        abc，无重复字母
        【思路】：1.深度优先遍历dfs，遍历每一个元素，从第一个元素出发创建一条路径，把元素加入第一步，并标记为已经使用，
        2.然后传入路径1，递归这个遍历，因为元素使用过会切换第二个元素，重复1加入元素标记已使用，直到结果满足输出要求a,b,c加入结果集。
        3.等1到底遍历完每个元素，开始回溯逆过程，a b c = c b a，依次撤销c b a，并撤销使用过的标记，这么做为了避免深度影响第二条路径遍历。
        */
        var permute = function (nums) {
            const res = []
            // 根据nums索引号确定是否使用过
            const used = []

            function permutes(path) {
                if (path.length === nums.length) {
                    //避免深度影响
                    res.push(path.slice())
                    return
                }
                for (let index = 0; index < nums.length; index++) {
                    const el = nums[index]
                    if (used[index]) {
                        continue
                    }
                    // 使用与标记
                    path.push(el)
                    used[index] = true
                    permutes(path)
                    // 回溯撤销
                    path.pop()
                    used[index] = false
                }
            }

            permute([])
            return res
        };

        /*
        田忌赛马【未经过机试】
        两组组数据a,b。请以田忌赛马的规则尽可能的排列a，使得a胜过b，返回a能胜多少次。
        全排列2的变体，在全排列2基础上加了新增条件，
        要加入结果数组，还需要这个排列能赢过b，也需要注意重复元素。
        */
        function tianjisaima(a, b) {
            const res = []
            const used = []
            a.sort()
            // 新增条件，元素是否大于b的元素，超过一半的元素大于即a赢，排除平局。
            // 赢一次+1，输一次=1，大于0即a胜。
            let win = 0

            function permute(path) {
                if (path.length === nums.length) {
                    if (win > 0) {
                        res.push(path.slice())
                    }
                    win = 0
                    return
                }

                for (let index = 0; index < a.length; index++) {
                    if (used[index]) {
                        continue
                    }

                    if (index - 1 >= 0 && a[index - 1] === a[index] && !used[index - 1]) {
                        continue
                    }

                    if (a[index] > b[index]) {
                        win += 1
                    }
                    else {
                        win = a[index] === b[index] ? win : win - 1
                    }

                    path.push(a[index])
                    used[index] = true
                    permute(path)
                    path.pop()
                    used[index] = false
                }
            }

            permute([])
            return res.length
        }
        // console.log(tianjisaima([11, 8, 20], [10, 13, 7]))

        /*
        寿司转盘
        寿司店酬宾，买一盘寿司n可以选择n+1方向最近的一盘寿司免费吃，但价格必须低于当前寿司。
        转一圈没有更低则没有赠送。寿司无限供应
        给出一组数据，1 2 6 8 5 7输出 1 2 11 13 6 8.注意，这是个转盘。
        【思路】暴力破解，遍历到当前元素，slice切片 再遍历，n+1 concat 0+n 切片即可。
        */

        /*
        出租车计费，靠谱的车
        出租车司机打表有问题，遇到任意位置上的4就会跳到5。给出一个费用，求解实际费用。
        【思路】暴力破解超时，两个变量统计，一个正常打表一个不正常直到不正常的满足给出费用。返回正常费用。
          
        */
    </script>
</body>

</html>