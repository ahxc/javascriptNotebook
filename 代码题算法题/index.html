<!DOCTYPE html>
<html lang="zh">

<head>
    <meta charset="UTF-8">
    <meta
        name="viewport"
        content="width=device-width, initial-scale=1.0"
    >
    <title>代码题算法题</title>
</head>

<style>
    .box1 {
        background-color: red;
        width: 100px;
        height: 100px;
    }

    .box2 {
        background-color: lightblue;
        width: 50px;
        height: 50px;
    }
</style>

<body>
    <div class="box1">
        <div class="box2"></div>
    </div>

    <script>
        /* 
        判断一个字符串是否为对称数
        例：'123321'
         */
        function symmetry(str = '') {
            return str === str.split('').reverse().join('');
        }
        // print();

        /* 
        使用 setTimeout 实现 setInterval，
        注意：setTimeout执行完毕不使用变量保存会自动清空不需手动清空。setInterval也没有立即执行属性但会立即执行一次。
        */
        function mySetInterval(fn, time) {
            fn()
            setTimeout(() => {
                mySetInterval(fn, time)
            }, time)
        }
        // 原生都将开辟新空间，所以i始终打印1
        // mySetInterval(() => {
        //     let i = 0;
        //     i += 1;
        //     console.log(i);
        // }, 1000);

        /* 
        查找第K个最大元素
        注意去重版和非去重要求，通常不用去重。去掉new set即可
         */
        function findKLargest(array, k) {
            const list = Array.from(new Set(array)).sort((a, b) => a - b);
            return list[k - 1];
        }

        /* 
        抚平嵌套数组
         */
        function flat(arr, n = 0) {
            let list = []
            arr.forEach((el) => {
                if (Array.isArray(el) && n > 0) {
                    list = list.concat(flat(el, n - 1))
                }
                else {
                    list.push(el)
                }
            })
            return list
        }
        // console.log(flat([1, 2, 3, [4, 5, 6], [7, 8, [9, 10, 11], 12], [13, 14, 15]], 2))

        /* 
        数组排序，先排数字，再排字母
        例子：["B3", "D2", "F1", "A9", "D12", "A2", "C1", "Z0", "B1"] 
        */
        function sortData(data) {
            return data.sort((a, b) => {
                const [matchA, codeA, numA] = a.match(/([A-Z])(\d+)/);
                const [matchB, codeB, numB] = b.match(/([A-Z])(\d+)/);

                const numComparison = parseInt(numA) - parseInt(numB);
                if (numComparison !== 0) {
                    return numComparison;
                }
                else {
                    // 比较字母顺序，升序返回-1，降序返回1，相同字母返回0。
                    return codeA.localeCompare(codeB);
                }
            });
        }
        const data = ["B3", "D2", "F1", "A9", "D12", "A2", "C1", "Z0", "B1"];
        // console.log(sortData(data))

        /* 
        使用promise每隔一秒输出123
        */
        async function print(time) {
            // 基础原理
            // for (let i = 1; i < 4; i++) {
            //     setTimeout(() => {
            //         console.log(i);
            //     }, i * 1000);
            // }

            // promise 改造
            for (let i = 1; i < 4; i++) {
                await pro(i); // await也要加上。
            }

            function pro(interval) {
                return new Promise((resolve, reject) => {
                    setTimeout(() => {
                        console.log(interval);
                        resolve(interval); // 无此句会一秒后同时打印出123，因为await 等不到返回结果，for循环会立即执行。
                    }, 1000);
                });
            }
        }
        // print()

        /* 
        盒子内部点击打印false，外部点击打印true，
        如果是vue的话使用.self修饰符，只有点击事件本身才会触发
         */
        var box1 = document.getElementsByClassName('box1')[0];
        box1.addEventListener('click', function (event) {
            var isInside = event.target === box1; // 冒泡的时候触发事件检查点击的是否是div元素本身
            console.log(isInside ? '内部点击' : '外部点击');
        });

        /* 
        深拷贝
         */
        function deepClone(data) {
            return JSON.parse(JSON.stringify(data));
        }

        const i = [
            { id: '1', value: '1' },
            { id: '2', value: '2' },
            { id: '3', value: '3' },
            { id: '1-1', value: '1-1', pid: '1' },
            { id: '2-1', value: '2-1', pid: '2' },
            { id: '3-1', value: '3-1', pid: '3' },
            { id: '3-1-1', value: '3-1-1', pid: '3-1' },
        ];
        // 把含树结构的array数据转换为children层级形式的array返回
        function list2tree(list = [], id = 'id', pid = 'pid') {
            // 深拷贝
            const d_list = deepClone(list);

            // key，value字典
            const dic = {};
            for (const i of d_list) {
                dic[i[id]] = i;
            }

            // 树
            const tree = [];
            let index = 0;
            for (const i of d_list) {
                const p = dic[i[pid]];
                if (p) {
                    p.children = p.children ? [...p.children, i] : [i];
                    i.level = (p.level || 0) + 1;
                }
                else {
                    i.level = 0;
                    tree.push(i);
                }
            }
            return deepClone(tree);
        }

        // 组件
        const com = {}
        // 根据上述list2tree生成的数据返回树组件
        function loopComponent(list) {
            for (const i of list) {
                if (Array.isArray(i.children)) {
                    loopComponent(i.children)
                }
                return com
            }
        }

        // 给数字字符串添加千分位，注意小数点。
        // 原生实现 number.toLocaleString() // '123,456.789'
        function addThousandSeparator(num) {
            var numParts = String(num).split(".");
            numParts[0] = numParts[0].replace(/\B(?=(\d{3})+(?!\d))/g, ","); // 找到千分位
            return numParts.join(".");
        }
        // console.log(addThousandSeparator('6666666.6666666666'))

        /* 
        json扁平化
        思路：数组扁平化一致，递归加融合
         */
        let json = {
            name: 'John',
            age: 30,
            address: {
                city: 'New York',
                state: 'NY',
                zip: '10001',
                addressPlus: {
                    city: 'new london'
                }
            },
            hobbies: ['reading', 'traveling', 'music', ['test', 'test2', ['test3']]]
        };
        function flattenJSON(obj = {}, prefix = '') {
            let result = {}
            for (const key of Object.keys(obj)) {
                const newPrefix = prefix ? prefix + '_' + key : key
                if (typeof obj[key] === 'object' && obj !== null) {
                    result = Object.assign(result, flattenJSON(obj[key], newPrefix))
                }
                else {
                    result[newPrefix] = obj[key]
                }
            }
            return result
        }
        // console.log(flattenJSON(json))

        /* 
        函数柯里化 实现
        (a,b,c)=>a+b+c
         */
        function curry(a) {
            return function (b) {
                return function (c) {
                    return a + b + c
                }
            }
        }
        // console.log(curry(1)(2)(3))

        /* 
        rgb转hex
        思路：toString(16)和填充前缀0
        三原色转十六进制颜色代码，如 255,255,255 => #ffffff
        */
        function num2hex(n) {
            return n.toString(16).padStart(2, '0')
        }
        function rgb2hex(r, g, b) {
            return '#' + num2hex(r) + num2hex(g) + num2hex(b)
        }
        // console.log(rgb2hex(255, 255, 255))

        // 平方根 sqrt，返回向下取整的整数
        function mySqrt(x) {
            // 整数x的平方根一定是在1到x的范围内，采用二分法
            let left = 1,
                right = x;
            while (left <= right) {
                let mid = left + ((right - left) >> 1); // 右移一位相当于除以2取中间值，这样写防止溢出。
                // 判断mid的平方是否小于或等于x，如果mid的平方小于x
                if (mid <= x / mid) {
                    // 判断(mid+1)的平方是否大于x，如果(mid+1)的平方大于x，那么mid就是x的平方根
                    if (mid + 1 > x / (mid + 1)) {
                        return mid;
                    }
                    // 如果mid的平方小于x并且(mid+1)的平方小于x，那么x的平方根比mid大，接下来搜索从mid+1到x的范围
                    left = mid + 1;
                }
                else {
                    // 如果mid的平方大于x，则x的平方根小于mid，接下来搜索1到mid-1的范围
                    right = mid - 1;
                }
            }
            // 如果输入参数是0，left等于1而right等于0，就直接返回0
            return 0;
        };
        // console.log(mySqrt(6))

        /* 
        for循环与var，let
        */
        for (var index = 0; index < 3; index++) {
            setTimeout(() => {
                // console.log(index)
            }, 0);
        }
        // 3 3 3，因为var已经加完，按事件循环机制再执行console。

        for (let index = 0; index < 3; index++) {
            setTimeout(() => {
                // console.log(index)
            }, 0);
        }
        // 0 1 2，块级作用域for循环参数index有闭包保护。他们都是经过延时后一同调用，因为时间循环机制。

        /* 
        this 指向问题
        */
        const fun = {
            count: 'ahxc',
            show: function () {
                console.log('show', this.count)
            }
        }
        const exc = fun.show
        // exc() // undefined ，对象是window
        // fun.show() // ahxc ，对象是fun

        var value = 100
        function fn() {
            this.value++;
            return this.value;
        }
        var obj = {
            value: 1,
            fn
        }
        function delay(fn, delay) {
            return new Promise((resolve) => {
                setTimeout(() => {
                    resolve(fn());
                }
                    , delay);
            })
        }
        async function run() {
            var value = 10;
            try {
                console.log(1)
                const pms1 = delay(fn, 100);
                const pms2 = delay(obj.fn, 200);
                const value1 = await pms1;
                const value2 = await pms2;
                const value3 = await delay(fn.bind(obj), 300);
                console.log(value1, value2, value3)
            }
            catch (err) {
                console.error(err);
            }
        }
        // 耗时 500，pms1 pms2 是同步调用。

        /* 
        空瓶换汽水，3个空瓶换一瓶汽水，喝完可以加入剩余空瓶继续换，
        剩到两个空瓶可以和老板借一个空瓶换汽水到时喝完还给老板。换句话说，剩两个空瓶后可换一瓶汽水。
        思路：如果n>3循环减去2（减三个加一个）可以算喝了一瓶，剩两个空瓶再喝一瓶
        */
        function bottle(n) {
            s = 0
            while (n >= 3) {
                n -= 2
                s += 1
            }
            if (n === 2) {
                s += 1
            }
            return s
        }
        // console.log(bottle(2))

        /* 
        n阶台阶问题，注意每次只能爬1和2阶台阶，n阶只能从n-1或n-2跳过来
        思路，所以n阶的跳法只能是n-1和n-2跳法的和，斐波那契数列去掉了0和1。0 1 1 2 3 5 8
        */
        function climbStairs(n) {
            if (n <= 2) return n
            let p = 1
            let q = 2
            for (let i = 3; i <= n; i++) {
                let temp = p
                p = q
                q = q + temp
            }
            return q
        }
        // console.log(climbStairs(2))

        /* 
        n阶台阶升级版，p，q是可以手动输入控制的，又有多少种解法，如3 1 2 输出3，p<=q=<n=<=100
        */
        function climbStairs(n, p, q) {

        }

        /* 
        验证有效ip地址
        思路：含 . ipv4 含:ipv6
        对于ipv4：一组0~255，没有0前缀，将每组化作整型再转回字符串，看是否等于自身，即可去掉0前缀和非法字符
        ipv6同理，0~ffff，a~f，注意ipv6可以有0前缀，所以转换十进制然后十六机制后的和自身都用0填充至4位即可。注意大小写，全部小写处理。
        */
        var validIPAddress = function (queryIP) {
            if (queryIP.includes('.')) {
                const list = queryIP.split('.')
                if (list.length !== 4) return 'Neither'
                for (const i of list) {
                    if (!checkip4(i)) {
                        return 'Neither'
                    }
                }
                return 'IPv4'
            }
            else {
                const list = queryIP.split(':')
                if (list.length !== 8) return 'Neither'
                for (const i of list) {
                    if (!checkip6(i)) {
                        return 'Neither'
                    }
                }
                return 'IPv6'
            }
        };

        function checkip4(str) {
            if (parseInt(str) > 255) {
                return false
            }
            // 如果是合法的转数字再转回去是不变的，有非法字符或前缀0或空串都不行，空串""''都为0
            if (String(parseInt(str)) !== str) {
                return false
            }
            return true
        }

        function checkip6(str) {
            if (str.length > 4) {
                return false
            }
            // 超出范围
            if (parseInt(str, 16) > parseInt('ffff', 16)) {
                return false
            }
            // ! 0dc8==dc8==DC8==dC8，统一转为小写，并用0补充空位；
            // 转为十进制然后回16进制排除非法字符如fGb2，g为非法字符，合理范围abcdef；
            if (parseInt(str, 16).toString(16).padStart(4, '0') !== str.padStart(4, '0').toLowerCase()) {
                return false
            }
            return true
        }
        // console.log(validIPAddress("2001:0db8:85a3:00000:0:8A2E:0370:7334"))

        /* 
        前k个高频词汇
        思路：用字典统计每个单词出现次数，然后根据次数排序即可，相同字数使用localeCompare字母单词排序即可。
        注意：如果是相同频率的单词，按照字典abc的顺序排序
        */
        function topKFrequent(params) {
            const dic = {}
            for (const i of words) {
                if (dic[i]) {
                    dic[i] += 1
                }
                else {
                    dic[i] = 1
                }
            }

            const list = Object.keys(dic).sort((a, b) => {
                if (dic[a] === dic[b]) {
                    return a.localeCompare(b) // 字母顺序
                }
                return dic[b] - dic[a]
            })
            return list.slice(0, k)
        }

        /* 
        反转句子
        hello word =》word hello
        注意首尾空格和空元素
         */
        function reverseWords(s) {
            const list = s.split(' ')
            return list.filter((item) => item).reverse().join(' ')
        };

        /* 
        重复子串
        思路：如果A连续子串能得出B，必有AAAABAAA，那么其重复子串A的长度不会超过ABA的长度。
        以此界限，暴力叠加A看包不包含B即可。
        重复子串A多少次能有B，注意A本身包含B算一次。没有B返回-1
        */
        function repeatedStringMatch(a, b) {
            const len = a.length * 2 + b.length
            let count = 1
            let temp = a
            while (temp.length <= len) {
                if (temp.includes(b)) {
                    return count
                }
                count += 1
                temp += a
            }
            return -1
        };

        /* 
        最长公共子串
        遍历每个元素，末端往元素靠拢暴力枚举
        注意：最优解可能在末尾，所以必须全部遍历完。
        */
        function commonSubStr(sub, main) {
            if (sub.length > main.length) {
                const temp = sub;
                sub = main;
                main = temp;
            }
            let length = 0;
            for (let i = 0; i < sub.length; i++) {
                let endIndex = sub.length;
                while (i < endIndex) {
                    const str = sub.slice(i, endIndex);
                    if (main.includes(str)) {
                        length = Math.max(length, str.length);
                        break;
                    } else {
                        endIndex -= 1;
                    }
                }
            }
            console.log(length);
        }

        /* 
        最长公共子串 动态规划升级版
        思路：利用二维数组，如果有匹配，则在左上角的基础上+1，左上角意味着有公共元素相交。形成一条递增对角线，
        保存这个对角线的最大值。
         */
        function commonSubStr(str1, str2) {
            // const zero = Array(str2.length + 1).fill(0); // 注意！不能这样写，因为fill都是同一个对象，会有深度影响，深拷贝也没用。
            // 只能新增一个for循环
            const sets = Array(str1.length + 1);
            for (let i = 0; i < sets.length; i++) {
                sets[i] = Array(str2.length + 1).fill(0)
            }

            let length = 0;
            for (let str1Index = 1; str1Index <= str1.length; str1Index++) {
                for (let str2Index = 1; str2Index <= str2.length; str2Index++) {
                    if (str1[str1Index - 1] === str2[str2Index - 1]) {
                        sets[str1Index][str2Index] =
                            sets[str1Index - 1][str2Index - 1] + 1;
                        length = Math.max(sets[str1Index][str2Index], length);
                    }
                }
            }
            console.log(length);
        }

        /* 
        十进制的反码，
        思路：toString(2)，即转二进制后1取0,0取1，然后转为十进制
        */
        var bitwiseComplement = function (n) {
            let N2 = n.toString(2)
            let str = ''
            for (let i = 0; i < N2.length; i++) {
                if (N2[i] === '0') {
                    str += '1'
                }
                else {
                    str += '0'
                }
            }
            return parseInt(str, 2)
        };

        /* 
        接雨水
        思路：计算左边和右边的最大短板超时，将每个单位视作一个木桶，能接多少水取决于他的短板。用最小短板-自身高度即可这个单位头顶有多少水
        */
        var trap = function (height) {
            const list = [] // 每个单位的最小短板集合
            let count = 0
            for (let i = 0; i < height.length; i++) {
                const left = Math.max(...height.slice(0, i), 0)
                const right = Math.max(...height.slice(i + 1), 0)
                list.push(left < right ? left : right)
            }
            for (let i = 0; i < height.length; i++) {
                count += Math.max(list[i] - height[i], 0)
            }

            return count
        }

        /*
        接雨水
        Math.max超时改造版
        用最大自增序列来分别计算左右短板替代max方法，空间复杂多两个递增序列  1 1 2 0 3 2...=》1 1 2 2 3 3 ...
        最大自增序列，即遇到新的最大值设为后续自增标准，以2为例，2的左最大短板是1是2无影响，装不了水。所以为2对齐后续。
        右最大短板按相反方向同时来一次即可
        */
        var trapPlus = function (height) {
            let count = 0

            const maxLeft = []
            const maxRight = []

            // 最大递增序列左右两个方向
            for (let i = 0; i < height.length; i++) {
                maxLeft.push(Math.max(maxLeft[i - 1] || 0, height[i]))
                maxRight.push(Math.max(maxRight[i - 1] || 0, height[height.length - 1 - i]))
            }

            for (let i = 0; i < height.length; i++) {
                const min = Math.min(maxLeft[i], maxRight[height.length - 1 - i])
                count += Math.max(min - height[i], 0)
            }
            return count
        }

        /*
       接雨水
       双指针版升级版
       思路：如果单位的左短板小于又短板，那么他可以装最多左短板-自身高度的水，注意这时左指针需要右移，而右指针不变！
       反之，单位的右短板小于左短板，那么他可以装最多右短板-自身高度的水，
       如若相等，则无所谓左右，拿其中一个短板-自身高度的水
       在移动双指针时，同步更新最大短板，注意不能遗漏指针合并时还一次计算
       本质是最大递增虚列的左右合并。
       */
        var trap = function (height) {
            let count = 0
            let maxLeft = 0 // 最大短板
            let maxRight = 0
            let leftIndex = 0
            let rightIndex = height.length - 1
            while (leftIndex <= rightIndex) {
                maxLeft = Math.max(maxLeft, height[leftIndex])
                maxRight = Math.max(maxRight, height[rightIndex])
                if (maxLeft < maxRight) {
                    count += maxLeft - height[leftIndex]
                    leftIndex += 1
                }
                else {
                    count += maxRight - height[rightIndex]
                    rightIndex -= 1
                }
            }
            return count
        }

        /* 
        1764.连接数组 groups（二维数组），nums（一维数组）
        能否在nums中找到groups所有子数组
        这些子数组顺序和groups子数组出现顺序一致，且不想交，满足true，反之false
        思路：遍历groups，groups和nums都用连接符逗号转字符串，通过indexOf计算索引。有一个找不到等于-1则false
        找到后利用slice切片切除之前所有部分，防止下一个找到后与上一个相交。
        注意：如果找到了，那么这个子串（子数组）的左边只存在两种情况：1.开头就找到了，所以左边没有元素undefined，中间找到了，那么左边应该是连接符','，下次匹配这个连接符需要切掉
        防止特殊情况：[[2,1]] [12,1]，这个找到后左边是1，应该是false
        */
        var canChoose = function (groups, nums) {
            nums = nums.join(',')
            for (const i of groups) {
                const sub = i.join(',')
                const index = nums.indexOf(sub)
                if (index === -1 || nums[index - 1] && nums[index - 1] !== ',') {
                    return false
                }
                nums = nums.slice(index + sub.length + 1)
            }
            return true
        };

        /*
        找座位，【没有经过机试】
        给定一组数据1000101001,1有人，0无人，在满足010，10,01的情况下，最多能坐多少人
        遍历字符串，如果为0，满足左边：undefined或0的情况下，则坐人。
        注意：计算过的位置要坐人改变状态，0000000000
        */
        function findPosition(n) {
            let count = 0
            n = n.split('')
            for (let i = 0; i < n.length; i++) {
                if (n[i] === '0') {
                    const left = n[i - 1] === '0' || i === 0
                    const right = n[i + 1] === '0' || i === n.length - 1
                    if (left && right) {
                        count += 1
                        // 坐上人
                        n.splice(i, 1, '1')
                    }
                }
            }
            return count
        }
        // console.log(findPosition('00100000001010'))

        /*
        最长瑕疵元音子串，暴力破解【没有经过机试】
        以aeiou开始和结尾的字符串为元音字符串，如a，aa，aeiou，abo
        瑕疵度flaw为元音字符串中有多少个非元音字母，a，aa瑕疵度为0，abo为1
        找出满足指定瑕疵度的最大元音子串。返回他的长度
        思路：和最长公共子串暴力解法类似，双指针遍历，末端往左指针靠拢，找到最长的且满足指定瑕疵即可。
        注意：与最长公共子串相同，答案可能在末尾，所以需要遍历完去最大值，
        */
        function aeiou(str, n) {
            const yuan = 'aeiou'
            let count = 0
            let length = 0
            for (let startIndex = 0; startIndex < str.length; startIndex++) {
                let endIndex = str.length - 1
                while (startIndex <= endIndex) {
                    const left = yuan.includes(str[startIndex])
                    const right = yuan.includes(str[endIndex])
                    const condition = n === computeFlaw(str.slice(startIndex, endIndex + 1))
                    if (left && right && condition) {
                        length = Math.max(str.slice(startIndex, endIndex + 1).length, length)
                    }
                    endIndex--
                }
            }
            return length
        }
        // 计算瑕疵度
        function computeFlaw(str) {
            const yuan = 'aeiou'
            let count = 0
            for (let index = 0; index < str.length; index++) {
                if (!yuan.includes(str[index])) {
                    count += 1
                }
            }
            return count
        }
        // console.log(aeiou('aabeebuu', 1))

        /* 
        掌握单词个数，暴力破解【没有经过机试】
        n个单词组成的str，每个单词能否用char拆开组合，如 abc  abstract，abc可以组合，
        char还包括?可以抵消一一个字母，万能字母。如abstra?t ，？抵消c
        输出多少个单词可以这样掌握。
        思路：可以统计每个单词的字母出现次数，和char对比。如果遇到单词字母次数大于>char字母次数，拿万能字母?抵消
        每个单词匹配都是重新开始，不消耗次数，但每次匹配char的字母只能匹配一次，包括万能字符。
        满足次数相等的计入掌握数
        */
        function takeWords(str, char) {
            const list = str.split(',')
            const dicChar = codeNums(char)
            dicChar['question'] = dicChar['question'] || 0
            let count = []
            for (let index = 0; index < list.length; index++) {
                const element = list[index];
                const dicWord = codeNums(element)
                let temp = dicChar['question'] // 记录初始问号数值下次匹配。
                let flag = true
                for (const i of Object.keys(dicWord)) {
                    if (dicWord[i] > (dicChar[i] || 0) + temp) {
                        flag = false
                        break
                    }
                    temp = Math.max(temp - dicWord[i] + (dicChar[i] || 0), 0)
                    console.log(dicWord[i], temp)
                }
                if (flag) {
                    count.push(element)
                }
            }
            return count
        }
        // 统计字母次数字典
        function codeNums(code) {
            const dic = {}
            for (let index = 0; index < code.length; index++) {
                const element = code[index];
                if (element === '?') {
                    dic["question"] = (dic["question"] || 0) + 1
                    continue
                }
                dic[element] = dic[element] ? dic[element] + 1 : 1
            }
            return dic
        }
        // console.log(takeWords('hello,world,cloud', 'welldonehohneyr'))

        /* 
        判断子序列
        判断一个字符串是否是另一个字符串的子序列，不要求连续，但顺序要保持一致，如 ace   asdfcwere。
        acb aewrbsdfec，则不行，因为b在c后面
        思路：暴力遍历，判断s中每个字符是否存在于t，如果存在，更新t开始搜索的索引后移避免顺序错误。
        这里可以用indexOf替代内层for循环。
        */
        var isSubsequence = function (s, t) {
            if (s.length > t.length) return false
            if (s.length === 0) return true
            let start = 0 // 开始搜索的位置，包含。
            for (let i = 0; i < s.length; i++) {
                const index = t.indexOf(s[i], start)
                if (index === -1) {
                    return false
                }
                start = index + 1
            }
            return true
        };

        /*
        找朋友，暴力遍历【没有经过机试】
        同学i往右看，有比他高的(第一个)则是好朋友，记录好朋友的索引位置。返回
        */
        function findFriends(str) {
            const list = str.split(',')
            count = Array(list.length).fill(0)
            for (let index = 0; index < list.length; index++) {
                const element = parseInt(list[index]);
                for (let indexf = index + 1; indexf < list.length; indexf++) {
                    const frind = parseInt(list[indexf]);
                    if (frind > element) {
                        count[index] = indexf
                        break
                    }
                }
            }
            return count
        }
        // console.log(findFriends('100,2,234,2123,23534,22,4432,543'))

        /* 
        电脑感染时间【未经过机试】
        给定一组二维数组，每子数组表示 电脑2 到 电脑1 感染时间1，最后一行2表示电脑病毒位置
        求病毒感染所有电脑所需的时间，感染同步进行，存在电脑不被感染即未连接网络，返回-1
        4 // 电脑数
        3 // 链接数
        2 1 1
        2 3 1
        3 4 1
        2
        答案为2 因为2-3花费1 3-4 花费1
        思路：1.要感染所有电脑，最少链接情况是一条直线，那么连接数应该等于电脑数-1 1-2-3-4
        但可能存在环，即 1-2-3  1-3这时连接数不可靠
        2.最长公共子串同样的道理，但横坐标和纵坐标相等，轴对称，如果动态规划左上角为0，意味着是存在独立链接。
        3.如果左上角为1，但自身为0，意味着靠近电脑顺序但没有连接
        */
        // function computerVirus(n, l, list, m) {
        //     if (l < n - 1) return -1
        //     // 格式化初始数据
        //     const net = list.split(',')
        //     for (let index = 0; index < net.length; index++) {
        //         net[index] = net[index].split(' ')
        //     }
        //     // 建立二维数组
        //     const sets = Array(n).fill([])
        //     for (let index = 0; index < sets.length; index++) {
        //         sets[index] = Array(n).fill(0);
        //     }
        //     // 画规划，net从1开始
        //     for (let index = 0; index < net.length; index++) {
        //         const element = net[index];
        //         const [a, b, t] = element
        //         sets[a - 1][b - 1] = t
        //         sets[b - 1][a - 1] = t // 轴对称
        //     }
        //     console.log(sets, net)
        //     // 计算时间和 -1
        //     const maxTime = 0
        //     for (let zindex = 0; zindex < sets.length; zindex++) {
        //         const element = sets[zindex];
        //         let zero = 0 // 这一行全为0
        //         // for (let xindex = 0; xindex < array.length; xindex++) {
        //         //     if (zindex !== 0 && xindex !== 0) {
        //         //         if (sets[zindex][xindex] > 0) {

        //         //         }
        //         //     }
        //         //     else {

        //         //     }
        //         // }
        //     }
        //     return maxTime
        // }
        // computerVirus(4, 3, '2 1 1,2 3 1,3 4 1', 2)
        function computerVirus(n, l, list, m) {
            // 格式化初始数据
            const net = list.split(',')
            for (let index = 0; index < net.length; index++) {
                net[index] = net[index].split(' ')
            }
            // 记录已感染的电脑，防止a感染b, b感染a 死循环。
            const dic = {}
            for (let index = 0; index < net.length; index++) {
                const element = net[index];
                const [a, b, t] = element
                // 找到病毒源，递归感染。
                if (a === m || b === m) {
                    dic[a]
                    virus(a, b, t)
                    break
                }
            }
        }
        function virus(a, b, t) {

        }
        // computerVirus(4, 3, '2 1 1,2 3 1,3 4 1', 2)

        /* 
        密码输入检测 【未经过机试】
        密码长度大于8，且必须包含1个大写字母，1个小写字母，1个数字，1个特殊字符
        注意：要拿退格后的字符串测试
        */
        function passwordCheck(str) {
            let password = []
            for (let index = 0; index < str.length; index++) {
                const element = str[index];
                if (element === '<') {
                    password.pop()
                    continue
                }
                else {
                    password.push(element)
                }
            }

            // 除字母数字以外的特殊字符，最好不要自己指定，因为可能会漏。
            const special = password.some((item) => {
                return !/[a-zA-Z0-9]/.test(item)
            })

            password = password.join('')

            // 数字
            let num = false
            if (/\d/.test(password)) {
                num = true
            }


            // 大小写
            const lower = password.toUpperCase() !== password // 有小写
            const upper = password.toLowerCase() === password // 有大写

            // 长度
            const length = password.length >= 8

            return `${password},${lower && upper && length && num && special}`
        }
        // console.log(passwordCheck('asdS#F<<<1<dfsaw#'))

        /*
        最小字符串 【未经过机试】
        最小字符串意为 按字母顺序的字符串 如 abcde是最小字符串，
        请只交换一对字母的位置 如 bcda acdb （排序后：abcd）变为最小的字符串。首字母排序次字母排序以此类推
        思路：先给字符串排序，找到第一位必是最小，然后找到原始字符串位置并交换，如果是相同字母，往后移指针判断
        注意：针队特殊用例如aaacdb aaabdc aaabcd，需要剔除掉重复的开头aaa，找到要交换位置的c。
        针对已经排序好的，等特殊情况需要特殊处理。
        */
        function minCode(str) {
            const newList = str.split('')
            const oldList = str.split('')
            newList.sort()

            for (let index = 0; index < newList.length; index++) {
                if (newList[index] === oldList[index]) {
                    continue
                }
                // 旧串种要被替换的字母
                const temp = oldList[index]

                // 新最小字母索引在旧串中的原始位置
                const sourceIndex = oldList.join('').indexOf(newList[index], index + 1)
                oldList.splice(index, 1, newList[index])
                oldList.splice(sourceIndex, 1, temp)
                return oldList.join('')
            }
            return oldList.join('')
        }
        // console.log(minCode('aaaaaaaccccbbbbb'))

        /*
        查找接口成功率最优时间段【未经过机试】
                     0 1 2   3 4 5 6
        给定一组数组 [0,2,100,0,2,2,5] 每个数值表示单位时间内接口失败的次数，
        给定一个容忍率minAverageLost，计算数组平均值小于minaveragelost的区间，比如2有
        0-1,3-5，这些区间平均值小于平均值。返回这些区间
        思路：1.建立一个list统计sum[i]前的总失败率，这样区间sum[j]到sum[i]的失败率等于 总sum[i]-总sum[j-1] 如 [0,2,102,102,104,106]
        2.然后双端暴力遍历，计算存在多少个区间，每个区间是否满足平均值小于minaveragelost，或者判断区间总失败率是否大于minaveragelost*区间长度。
        注意：1.注意题意，只计算区间，单个元素不计入返回。和单个元素也计入区间有区别。满足条件的，区间内的单个元素需要排除，区间外的单独输出。如
        2 0,2,100,0,2,2,5,2,5 倒数第二个是可以单独作为区间输出
        2.区间内存在多个子区间满足条件，取最大区间，如3-4 3-6，右端遍历到6满足条件可以直接跳出当层循环不用计算3-4
        3-6 4-6左端遍历也应该取最大区间，可以设值一个变量 最大区间右索引，如果有该值，且左索引小于该值，则跳过当前循环，意味着找到了满足条件的最大区间。
        */
        function computeAverageLost(minAverageLost, str) {
            const list = str.split(',')

            const sum = Array(list.length).fill(0)
            for (let index = 0; index < list.length; index++) {
                sum[index] = parseInt(sum[index - 1] || 0) + parseInt(list[index]);
            }

            const count = []
            let maxRightIndex = -1
            for (let leftIndex = 0; leftIndex < list.length; leftIndex++) {
                // 左边开始的缩减的子区间都可以不再计算。
                if (maxRightIndex >= 0 && leftIndex <= maxRightIndex) {
                    leftIndex = maxRightIndex
                    continue
                }
                for (let rightIndex = list.length - 1; leftIndex <= rightIndex; rightIndex--) {
                    let avarage = (sum[rightIndex] - (sum[leftIndex - 1] || 0)) / (rightIndex - leftIndex + 1)
                    if (avarage <= minAverageLost) {
                        count.push(`${leftIndex === rightIndex ? leftIndex + '' : leftIndex + '-' + rightIndex}`)
                        maxRightIndex = rightIndex
                        // 右边开始缩减的子区间都可以不用在计算。
                        break
                    }
                }
            }
            return count.join(' ')
        }
        // console.log(computeAverageLost(2, '0,0,100,2,2,99,0,2'))

        /*
        分割平衡字符串
        给定一个均衡字符串只包含两种字符xy，且xy个数相等 xyyxyxxxyy 可分割为 xy yx yx xxyy 4
        请尽可能分割成多个连续子串，使得每个子串亦是均衡字符串，返回最大均衡字符串个数。
        思路：建立一个平衡度0，一次遍历遇到x平衡度+1，遇到y-1抵消平衡度
        平衡度为0表示达到了最小平衡，计入一次子串，类似括号匹配。
        */
        var balancedStringSplit = function (s) {
            let count = 0
            let blance = 0
            for (let i = 0; i < s.length; i++) {
                if (s[i] === 'L') {
                    blance += 1
                }
                else {
                    blance -= 1
                }
                if (blance === 0) {
                    count += 1
                }
            }
            return count
        };

        /*
        单位时间内通过车辆最多颜色数量
        每一秒通过一两车，[0,1,1,2]4秒，共3种车，0,1,2
        给定一个时间n秒，计算n秒内出现颜色种类最多的车能有多少，
        思路：暴力遍历，就是一个时间划窗[left,...,right]，从头划窗，窗内颜色种内最多。
        加入【同向双指针】模拟划窗，即划窗右端为开始指针，紧跟着左端指针，右端划过一个元素，左端需要跟上。
        如：3秒内，滑到1,1,1时，0被左指针指着，应该减1。能将时间复杂度o(length*(n+m))=>o(length*n)
        */
        function countColorCar(str, n) {
            const list = str.split(' ')
            let maxCount = 0
            // 存储 0 1 2 车出现次数
            const count = Array(3).fill(0)
            let leftIndex = 0
            for (let rightIndex = 0; rightIndex < list.length; rightIndex++) {
                count[list[rightIndex]] += 1
                // 划窗又划过来了一个元素，右指针减去左指针长度大于n，等于n因为刚好初始化划过第一个一个元素不会触发下面代码
                while (rightIndex - leftIndex >= n) {
                    // 对齐
                    // 减去划窗略过的元素的次数
                    count[list[leftIndex]] -= 1
                    leftIndex += 1
                }
                maxCount = Math.max(maxCount, ...count)
            }
            return maxCount
        }
        // console.log(countColorCar('0 0 0 0 0', 0))
    </script>
</body>

</html>