<!DOCTYPE html>
<html lang="zh">

<head>
    <meta charset="UTF-8">
    <meta
        name="viewport"
        content="width=device-width, initial-scale=1.0"
    >
    <title>代码题算法题</title>
</head>

<style>
    .box1 {
        background-color: red;
        width: 100px;
        height: 100px;
    }

    .box2 {
        background-color: lightblue;
        width: 50px;
        height: 50px;
    }
</style>

<body>
    <div class="box1">
        <div class="box2"></div>
    </div>

    <script>
        /* 
        判断一个字符串是否为对称数
        例：'123321'
         */
        function symmetry(str = '') {
            return str === str.split('').reverse().join('');
        }
        // print();

        /* 
        使用 setTimeout 实现 setInterval，
        注意：setTimeout执行完毕不使用变量保存会自动清空不需手动清空。setInterval也没有立即执行属性但会立即执行一次。
        */
        function mySetInterval(fn, time) {
            fn()
            setTimeout(() => {
                mySetInterval(fn, time)
            }, time)
        }
        // 原生都将开辟新空间，所以i始终打印1
        // mySetInterval(() => {
        //     let i = 0;
        //     i += 1;
        //     console.log(i);
        // }, 1000);

        /* 
        查找第K个最大元素
        注意去重版和非去重要求，通常不用去重。去掉new set即可
         */
        function findKLargest(array, k) {
            const list = Array.from(new Set(array)).sort((a, b) => a - b);
            return list[k - 1];
        }

        /* 
        抚平嵌套数组
         */
        function flat(arr, n = 0) {
            let list = []
            arr.forEach((el) => {
                if (Array.isArray(el) && n > 0) {
                    list = list.concat(flat(el, n - 1))
                }
                else {
                    list.push(el)
                }
            })
            return list
        }
        // console.log(flat([1, 2, 3, [4, 5, 6], [7, 8, [9, 10, 11], 12], [13, 14, 15]], 2))

        /* 
        数组排序，先排数字，再排字母
        例子：["B3", "D2", "F1", "A9", "D12", "A2", "C1", "Z0", "B1"] 
        */
        function sortData(data) {
            return data.sort((a, b) => {
                const [matchA, codeA, numA] = a.match(/([A-Z])(\d+)/);
                const [matchB, codeB, numB] = b.match(/([A-Z])(\d+)/);

                const numComparison = parseInt(numA) - parseInt(numB);
                if (numComparison !== 0) {
                    return numComparison;
                }
                else {
                    // 比较字母顺序，升序返回-1，降序返回1，相同字母返回0。
                    return codeA.localeCompare(codeB);
                }
            });
        }
        const data = ["B3", "D2", "F1", "A9", "D12", "A2", "C1", "Z0", "B1"];
        // console.log(sortData(data))

        /* 
        使用promise每隔一秒输出123
        */
        async function print(time) {
            // 基础原理
            // for (let i = 1; i < 4; i++) {
            //     setTimeout(() => {
            //         console.log(i);
            //     }, i * 1000);
            // }

            // promise 改造
            for (let i = 1; i < 4; i++) {
                await pro(i); // await也要加上。
            }

            function pro(interval) {
                return new Promise((resolve, reject) => {
                    setTimeout(() => {
                        console.log(interval);
                        resolve(interval); // 无此句会一秒后同时打印出123，因为await 等不到返回结果，for循环会立即执行。
                    }, 1000);
                });
            }
        }
        // print()

        /* 
        盒子内部点击打印false，外部点击打印true，
        如果是vue的话使用.self修饰符，只有点击事件本身才会触发
         */
        var box1 = document.getElementsByClassName('box1')[0];
        box1.addEventListener('click', function (event) {
            var isInside = event.target === box1; // 冒泡的时候触发事件检查点击的是否是div元素本身
            console.log(isInside ? '内部点击' : '外部点击');
        });

        /* 
        深拷贝
         */
        function deepClone(data) {
            return JSON.parse(JSON.stringify(data));
        }

        const i = [
            { id: '1', value: '1' },
            { id: '2', value: '2' },
            { id: '3', value: '3' },
            { id: '1-1', value: '1-1', pid: '1' },
            { id: '2-1', value: '2-1', pid: '2' },
            { id: '3-1', value: '3-1', pid: '3' },
            { id: '3-1-1', value: '3-1-1', pid: '3-1' },
        ];
        // 把含树结构的array数据转换为children层级形式的array返回
        function list2tree(list = [], id = 'id', pid = 'pid') {
            // 深拷贝
            const d_list = deepClone(list);

            // key，value字典
            const dic = {};
            for (const i of d_list) {
                dic[i[id]] = i;
            }

            // 树
            const tree = [];
            let index = 0;
            for (const i of d_list) {
                const p = dic[i[pid]];
                if (p) {
                    p.children = p.children ? [...p.children, i] : [i];
                    i.level = (p.level || 0) + 1;
                }
                else {
                    i.level = 0;
                    tree.push(i);
                }
            }
            return deepClone(tree);
        }

        // 组件
        const com = {}
        // 根据上述list2tree生成的数据返回树组件
        function loopComponent(list) {
            for (const i of list) {
                if (Array.isArray(i.children)) {
                    loopComponent(i.children)
                }
                return com
            }
        }

        // 给数字字符串添加千分位，注意小数点。
        // 原生实现 number.toLocaleString() // '123,456.789'
        function addThousandSeparator(num) {
            var numParts = String(num).split(".");
            numParts[0] = numParts[0].replace(/\B(?=(\d{3})+(?!\d))/g, ","); // 找到千分位
            return numParts.join(".");
        }
        // console.log(addThousandSeparator('6666666.6666666666'))

        /* 
        json扁平化
        思路：数组扁平化一致，递归加融合
         */
        let json = {
            name: 'John',
            age: 30,
            address: {
                city: 'New York',
                state: 'NY',
                zip: '10001',
                addressPlus: {
                    city: 'new london'
                }
            },
            hobbies: ['reading', 'traveling', 'music', ['test', 'test2', ['test3']]]
        };
        function flattenJSON(obj = {}, prefix = '') {
            let result = {}
            for (const key of Object.keys(obj)) {
                const newPrefix = prefix ? prefix + '_' + key : key
                if (typeof obj[key] === 'object' && obj !== null) {
                    result = Object.assign(result, flattenJSON(obj[key], newPrefix))
                }
                else {
                    result[newPrefix] = obj[key]
                }
            }
            return result
        }
        // console.log(flattenJSON(json))

        /* 
        函数柯里化 实现
        (a,b,c)=>a+b+c
         */
        function curry(a) {
            return function (b) {
                return function (c) {
                    return a + b + c
                }
            }
        }
        // console.log(curry(1)(2)(3))

        /* 
        rgb转hex
        思路：toString(16)和填充前缀0
        三原色转十六进制颜色代码，如 255,255,255 => #ffffff
        */
        function num2hex(n) {
            return n.toString(16).padStart(2, '0')
        }
        function rgb2hex(r, g, b) {
            return '#' + num2hex(r) + num2hex(g) + num2hex(b)
        }
        // console.log(rgb2hex(255, 255, 255))

        // 平方根 sqrt，返回向下取整的整数
        function mySqrt(x) {
            // 整数x的平方根一定是在1到x的范围内，采用二分法
            let left = 1,
                right = x;
            while (left <= right) {
                let mid = left + ((right - left) >> 1); // 右移一位相当于除以2取中间值，这样写防止溢出。
                // 判断mid的平方是否小于或等于x，如果mid的平方小于x
                if (mid <= x / mid) {
                    // 判断(mid+1)的平方是否大于x，如果(mid+1)的平方大于x，那么mid就是x的平方根
                    if (mid + 1 > x / (mid + 1)) {
                        return mid;
                    }
                    // 如果mid的平方小于x并且(mid+1)的平方小于x，那么x的平方根比mid大，接下来搜索从mid+1到x的范围
                    left = mid + 1;
                }
                else {
                    // 如果mid的平方大于x，则x的平方根小于mid，接下来搜索1到mid-1的范围
                    right = mid - 1;
                }
            }
            // 如果输入参数是0，left等于1而right等于0，就直接返回0
            return 0;
        };
        // console.log(mySqrt(6))

        /* 
        for循环与var，let
        */
        for (var index = 0; index < 3; index++) {
            setTimeout(() => {
                // console.log(index)
            }, 0);
        }
        // 3 3 3，因为var已经加完，按事件循环机制再执行console。

        for (let index = 0; index < 3; index++) {
            setTimeout(() => {
                // console.log(index)
            }, 0);
        }
        // 0 1 2，块级作用域for循环参数index有闭包保护。他们都是经过延时后一同调用，因为时间循环机制。

        /* 
        this 指向问题
        */
        const fun = {
            count: 'ahxc',
            show: function () {
                console.log('show', this.count)
            }
        }
        const exc = fun.show
        // exc() // undefined ，对象是window
        // fun.show() // ahxc ，对象是fun

        var value = 100
        function fn() {
            this.value++;
            return this.value;
        }
        var obj = {
            value: 1,
            fn
        }
        function delay(fn, delay) {
            return new Promise((resolve) => {
                setTimeout(() => {
                    resolve(fn());
                }
                    , delay);
            })
        }
        async function run() {
            var value = 10;
            try {
                console.log(1)
                const pms1 = delay(fn, 100);
                const pms2 = delay(obj.fn, 200);
                const value1 = await pms1;
                const value2 = await pms2;
                const value3 = await delay(fn.bind(obj), 300);
                console.log(value1, value2, value3)
            }
            catch (err) {
                console.error(err);
            }
        }
        // 耗时 500，pms1 pms2 是同步调用。

        /* 
        空瓶换汽水，3个空瓶换一瓶汽水，喝完可以加入剩余空瓶继续换，
        剩到两个空瓶可以和老板借一个空瓶换汽水到时喝完还给老板。换句话说，剩两个空瓶后可换一瓶汽水。
        思路：如果n>3循环减去2（减三个加一个）可以算喝了一瓶，剩两个空瓶再喝一瓶
        */
        function bottle(n) {
            s = 0
            while (n >= 3) {
                n -= 2
                s += 1
            }
            if (n === 2) {
                s += 1
            }
            return s
        }
        // console.log(bottle(2))

        /* 
        n阶台阶问题，注意每次只能爬1和2阶台阶，n阶只能从n-1或n-2跳过来
        思路，所以n阶的跳法只能是n-1和n-2跳法的和，斐波那契数列去掉了0和1。0 1 1 2 3 5 8
        */
        function climbStairs(n) {
            if (n <= 2) return n
            let p = 1
            let q = 2
            for (let i = 3; i <= n; i++) {
                let temp = p
                p = q
                q = q + temp
            }
            return q
        }
        // console.log(climbStairs(2))

        /* 
        n阶台阶升级版，p，q是可以手动输入控制的，又有多少种解法，如3 1 2 输出3，p<=q=<n=<=100
        */
        function climbStairs(n, p, q) {

        }

        /* 
        验证有效ip地址
        思路：含 . ipv4 含:ipv6
        对于ipv4：一组0~255，没有0前缀，将每组化作整型再转回字符串，看是否等于自身，即可去掉0前缀和非法字符
        ipv6同理，0~ffff，a~f，注意ipv6可以有0前缀，所以转换十进制然后十六机制后的和自身都用0填充至4位即可。注意大小写，全部小写处理。
        */
        var validIPAddress = function (queryIP) {
            if (queryIP.includes('.')) {
                const list = queryIP.split('.')
                if (list.length !== 4) return 'Neither'
                for (const i of list) {
                    if (!checkip4(i)) {
                        return 'Neither'
                    }
                }
                return 'IPv4'
            }
            else {
                const list = queryIP.split(':')
                if (list.length !== 8) return 'Neither'
                for (const i of list) {
                    if (!checkip6(i)) {
                        return 'Neither'
                    }
                }
                return 'IPv6'
            }
        };

        function checkip4(str) {
            if (parseInt(str) > 255) {
                return false
            }
            // 如果是合法的转数字再转回去是不变的，有非法字符或前缀0或空串都不行，空串""''都为0
            if (String(parseInt(str)) !== str) {
                return false
            }
            return true
        }

        function checkip6(str) {
            if (str.length > 4) {
                return false
            }
            // 超出范围
            if (parseInt(str, 16) > parseInt('ffff', 16)) {
                return false
            }
            // ! 0dc8==dc8==DC8==dC8，统一转为小写，并用0补充空位；
            // 转为十进制然后回16进制排除非法字符如fGb2，g为非法字符，合理范围abcdef；
            if (parseInt(str, 16).toString(16).padStart(4, '0') !== str.padStart(4, '0').toLowerCase()) {
                return false
            }
            return true
        }
        // console.log(validIPAddress("2001:0db8:85a3:00000:0:8A2E:0370:7334"))

        /* 
        前k个高频词汇
        思路：用字典统计每个单词出现次数，然后根据次数排序即可，相同字数使用localeCompare字母单词排序即可。
        注意：如果是相同频率的单词，按照字典abc的顺序排序
        */
        function topKFrequent(params) {
            const dic = {}
            for (const i of words) {
                if (dic[i]) {
                    dic[i] += 1
                }
                else {
                    dic[i] = 1
                }
            }

            const list = Object.keys(dic).sort((a, b) => {
                if (dic[a] === dic[b]) {
                    return a.localeCompare(b) // 字母顺序
                }
                return dic[b] - dic[a]
            })
            return list.slice(0, k)
        }

        /* 
        反转句子
        hello word =》word hello
        注意首尾空格和空元素
         */
        function reverseWords(s) {
            const list = s.split(' ')
            return list.filter((item) => item).reverse().join(' ')
        };

        /* 
        重复子串
        思路：如果A连续子串能得出B，必有AAAABAAA，那么其重复子串A的长度不会超过ABA的长度。
        以此界限，暴力叠加A看包不包含B即可。
        重复子串A多少次能有B，注意A本身包含B算一次。没有B返回-1
        */
        function repeatedStringMatch(a, b) {
            const len = a.length * 2 + b.length
            let count = 1
            let temp = a
            while (temp.length <= len) {
                if (temp.includes(b)) {
                    return count
                }
                count += 1
                temp += a
            }
            return -1
        };

        /* 
        最长公共子串
        遍历每个元素，末端往元素靠拢暴力枚举
        注意：最优解可能在末尾，所以必须全部遍历完。
        */
        function commonSubStr(sub, main) {
            if (sub.length > main.length) {
                const temp = sub;
                sub = main;
                main = temp;
            }
            let length = 0;
            for (let i = 0; i < sub.length; i++) {
                let endIndex = sub.length;
                while (i < endIndex) {
                    const str = sub.slice(i, endIndex);
                    if (main.includes(str)) {
                        length = Math.max(length, str.length);
                        break;
                    } else {
                        endIndex -= 1;
                    }
                }
            }
            console.log(length);
        }

        /* 
        最长公共子串 动态规划升级版
        思路：利用二维数组，如果有匹配，则在左上角的基础上+1，左上角意味着有公共元素相交。形成一条递增对角线，
        保存这个对角线的最大值。
         */
        function commonSubStr(str1, str2) {
            // const zero = Array(str2.length + 1).fill(0); // 注意！不能这样写，因为fill都是同一个对象，会有深度影响，深拷贝也没用。
            // 只能新增一个for循环
            const sets = Array(str1.length + 1);
            for (let i = 0; i < sets.length; i++) {
                sets[i] = Array(str2.length + 1).fill(0)
            }

            let length = 0;
            for (let str1Index = 1; str1Index <= str1.length; str1Index++) {
                for (let str2Index = 1; str2Index <= str2.length; str2Index++) {
                    if (str1[str1Index - 1] === str2[str2Index - 1]) {
                        sets[str1Index][str2Index] =
                            sets[str1Index - 1][str2Index - 1] + 1;
                        length = Math.max(sets[str1Index][str2Index], length);
                    }
                }
            }
            console.log(length);
        }

        /* 
        十进制的反码，
        思路：toString(2)，即转二进制后1取0,0取1，然后转为十进制
        */
        var bitwiseComplement = function (n) {
            let N2 = n.toString(2)
            let str = ''
            for (let i = 0; i < N2.length; i++) {
                if (N2[i] === '0') {
                    str += '1'
                }
                else {
                    str += '0'
                }
            }
            return parseInt(str, 2)
        };

        /* 
        接雨水
        思路：计算左边和右边的最大短板超时，将每个单位视作一个木桶，能接多少水取决于他的短板。用最小短板-自身高度即可这个单位头顶有多少水
        */
        var trap = function (height) {
            const list = [] // 每个单位的最小短板集合
            let count = 0
            for (let i = 0; i < height.length; i++) {
                const left = Math.max(...height.slice(0, i), 0)
                const right = Math.max(...height.slice(i + 1), 0)
                list.push(left < right ? left : right)
            }
            for (let i = 0; i < height.length; i++) {
                count += Math.max(list[i] - height[i], 0)
            }

            return count
        }

        /*
        接雨水
        Math.max超时改造版
        用最大自增序列来分别计算左右短板替代max方法，空间复杂多两个递增序列  1 1 2 0 3 2...=》1 1 2 2 3 3 ...
        最大自增序列，即遇到新的最大值设为后续自增标准，以2为例，2的左最大短板是1是2无影响，装不了水。所以为2对齐后续。
        右最大短板按相反方向同时来一次即可
        */
        var trapPlus = function (height) {
            let count = 0

            const maxLeft = []
            const maxRight = []

            // 最大递增序列左右两个方向
            for (let i = 0; i < height.length; i++) {
                maxLeft.push(Math.max(maxLeft[i - 1] || 0, height[i]))
                maxRight.push(Math.max(maxRight[i - 1] || 0, height[height.length - 1 - i]))
            }

            for (let i = 0; i < height.length; i++) {
                const min = Math.min(maxLeft[i], maxRight[height.length - 1 - i])
                count += Math.max(min - height[i], 0)
            }
            return count
        }

        /*
       接雨水
       双指针版升级版
       思路：如果单位的左短板小于又短板，那么他可以装最多左短板-自身高度的水，注意这时左指针需要右移，而右指针不变！
       反之，单位的右短板小于左短板，那么他可以装最多右短板-自身高度的水，
       如若相等，则无所谓左右，拿其中一个短板-自身高度的水
       在移动双指针时，同步更新最大短板，注意不能遗漏指针合并时还一次计算
       本质是最大递增虚列的左右合并。
       */
        var trap = function (height) {
            let count = 0
            let maxLeft = 0 // 最大短板
            let maxRight = 0
            let leftIndex = 0
            let rightIndex = height.length - 1
            while (leftIndex <= rightIndex) {
                maxLeft = Math.max(maxLeft, height[leftIndex])
                maxRight = Math.max(maxRight, height[rightIndex])
                if (maxLeft < maxRight) {
                    count += maxLeft - height[leftIndex]
                    leftIndex += 1
                }
                else {
                    count += maxRight - height[rightIndex]
                    rightIndex -= 1
                }
            }
            return count
        }

        /* 
        1764.连接数组 groups（二维数组），nums（一维数组）
        能否在nums中找到groups所有子数组
        这些子数组顺序和groups子数组出现顺序一致，且不想交，满足true，反之false
        思路：遍历groups，groups和nums都用连接符逗号转字符串，通过indexOf计算索引。有一个找不到等于-1则false
        找到后利用slice切片切除之前所有部分，防止下一个找到后与上一个相交。
        注意：如果找到了，那么这个子串（子数组）的左边只存在两种情况：1.开头就找到了，所以左边没有元素undefined，中间找到了，那么左边应该是连接符','，下次匹配这个连接符需要切掉
        防止特殊情况：[[2,1]] [12,1]，这个找到后左边是1，应该是false
        */
        var canChoose = function (groups, nums) {
            nums = nums.join(',')
            for (const i of groups) {
                const sub = i.join(',')
                const index = nums.indexOf(sub)
                if (index === -1 || nums[index - 1] && nums[index - 1] !== ',') {
                    return false
                }
                nums = nums.slice(index + sub.length + 1)
            }
            return true
        };

        /*
        找座位，【没有经过机试】
        给定一组数据1000101001,1有人，0无人，在满足010，10,01的情况下，最多能坐多少人
        遍历字符串，如果为0，满足左边：undefined或0的情况下，则坐人。
        注意：计算过的位置要坐人改变状态，0000000000
        */
        function findPosition(n) {
            let count = 0
            n = n.split('')
            for (let i = 0; i < n.length; i++) {
                if (n[i] === '0') {
                    const left = n[i - 1] === '0' || i === 0
                    const right = n[i + 1] === '0' || i === n.length - 1
                    if (left && right) {
                        count += 1
                        // 坐上人
                        n.splice(i, 1, '1')
                    }
                }
            }
            return count
        }
        // console.log(findPosition('00100000001010'))

        /*
        最长瑕疵元音子串，暴力破解【没有经过机试】
        以aeiou开始和结尾的字符串为元音字符串，如a，aa，aeiou，abo
        瑕疵度flaw为元音字符串中有多少个非元音字母，a，aa瑕疵度为0，abo为1
        找出满足指定瑕疵度的最大元音子串。返回他的长度
        思路：和最长公共子串暴力解法类似，双指针遍历，末端往左指针靠拢，找到最长的且满足指定瑕疵即可。
        注意：与最长公共子串相同，答案可能在末尾，所以需要遍历完去最大值，
        */
        function aeiou(str, n) {
            const yuan = 'aeiou'
            let count = 0
            let length = 0
            for (let startIndex = 0; startIndex < str.length; startIndex++) {
                let endIndex = str.length - 1
                while (startIndex <= endIndex) {
                    const left = yuan.includes(str[startIndex])
                    const right = yuan.includes(str[endIndex])
                    const condition = n === computeFlaw(str.slice(startIndex, endIndex + 1))
                    if (left && right && condition) {
                        length = Math.max(str.slice(startIndex, endIndex + 1).length, length)
                    }
                    endIndex--
                }
            }
            return length
        }
        // 计算瑕疵度
        function computeFlaw(str) {
            const yuan = 'aeiou'
            let count = 0
            for (let index = 0; index < str.length; index++) {
                if (!yuan.includes(str[index])) {
                    count += 1
                }
            }
            return count
        }
        // console.log(aeiou('aabeebuu', 1))

        /* 
        掌握单词个数，暴力破解【没有经过机试】
        n个单词组成的str，每个单词能否用char拆开组合，如 abc  abstract，abc可以组合，
        char还包括?可以抵消一一个字母，万能字母。如abstra?t ，？抵消c
        输出多少个单词可以这样掌握。
        思路：可以统计每个单词的字母出现次数，和char对比。如果遇到单词字母次数大于>char字母次数，拿万能字母?抵消
        每个单词匹配都是重新开始，不消耗次数，但每次匹配char的字母只能匹配一次，包括万能字符。
        满足次数相等的计入掌握数
        */
        function takeWords(str, char) {
            const list = str.split(',')
            const dicChar = codeNums(char)
            dicChar['question'] = dicChar['question'] || 0
            let count = []
            for (let index = 0; index < list.length; index++) {
                const element = list[index];
                const dicWord = codeNums(element)
                let temp = dicChar['question'] // 记录初始问号数值下次匹配。
                let flag = true
                for (const i of Object.keys(dicWord)) {
                    if (dicWord[i] > (dicChar[i] || 0) + temp) {
                        flag = false
                        break
                    }
                    temp = Math.max(temp - dicWord[i] + (dicChar[i] || 0), 0)
                    console.log(dicWord[i], temp)
                }
                if (flag) {
                    count.push(element)
                }
            }
            return count
        }
        // 统计字母次数字典
        function codeNums(code) {
            const dic = {}
            for (let index = 0; index < code.length; index++) {
                const element = code[index];
                if (element === '?') {
                    dic["question"] = (dic["question"] || 0) + 1
                    continue
                }
                dic[element] = dic[element] ? dic[element] + 1 : 1
            }
            return dic
        }
        // console.log(takeWords('hello,world,cloud', 'welldonehohneyr'))
    </script>
</body>

</html>