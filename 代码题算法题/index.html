<!DOCTYPE html>
<html lang="zh">

<head>
    <meta charset="UTF-8">
    <meta
        name="viewport"
        content="width=device-width, initial-scale=1.0"
    >
    <title>代码题算法题</title>
</head>

<style>
    .box1 {
        background-color: red;
        width: 100px;
        height: 100px;
    }

    .box2 {
        background-color: lightblue;
        width: 50px;
        height: 50px;
    }
</style>

<body>
    <div class="box1">
        <div class="box2"></div>
    </div>

    <script>
        /* 
        判断一个字符串是否为对称数
        例：'123321'
         */
        function symmetry(str = '') {
            return str === str.split('').reverse().join('');
        }
        // print();

        /* 
        使用 setTimeout 实现 setInterval，
        注意：setTimeout执行完毕不使用变量保存会自动清空不需手动清空。setInterval也没有立即执行属性但会立即执行一次。。
        */
        function mySetInterval(fn, time) {
            fn()
            setTimeout(() => {
                mySetInterval(fn, time)
            }, time)
        }
        // 原生都将开辟新空间，所以i始终打印1
        // mySetInterval(() => {
        //     let i = 0;
        //     i += 1;
        //     console.log(i);
        // }, 1000);

        /* 
        查找第K个最大元素
        注意去重版和非去重要求，通常不用去重。去掉new set即可
         */
        function findKLargest(array, k) {
            const list = Array.from(new Set(array)).sort((a, b) => a - b);
            return list[k - 1];
        }

        /* 
        抚平嵌套数组
         */
        function flat(arr, n = 0) {
            let list = []
            arr.forEach((el) => {
                if (Array.isArray(el) && n > 0) {
                    list = list.concat(flat(el, n - 1))
                }
                else {
                    list.push(el)
                }
            })
            return list
        }
        // console.log(flat([1, 2, 3, [4, 5, 6], [7, 8, [9, 10, 11], 12], [13, 14, 15]], 2))

        /* 
        数组排序，先排数字，再排字母
        例子：["B3", "D2", "F1", "A9", "D12", "A2", "C1", "Z0", "B1"] 
        */
        function sortData(data) {
            return data.sort((a, b) => {
                const [matchA, codeA, numA] = a.match(/([A-Z])(\d+)/);
                const [matchB, codeB, numB] = b.match(/([A-Z])(\d+)/);

                const numComparison = parseInt(numA) - parseInt(numB);
                if (numComparison !== 0) {
                    return numComparison;
                }
                else {
                    // 比较字母顺序，升序返回-1，降序返回1，相同字母返回0。
                    return codeA.localeCompare(codeB);
                }

            });
        }
        const data = ["B3", "D2", "F1", "A9", "D12", "A2", "C1", "Z0", "B1"];
        // console.log(sortData(data))

        /* 
        使用promise每隔一秒输出123
        */
        async function print(time) {
            // 基础原理
            // for (let i = 1; i < 4; i++) {
            //     setTimeout(() => {
            //         console.log(i);
            //     }, i * 1000);
            // }

            // promise 改造
            for (let i = 1; i < 4; i++) {
                await pro(i); // await也要加上。
            }

            function pro(interval) {
                return new Promise((resolve, reject) => {
                    setTimeout(() => {
                        console.log(interval);
                        resolve(interval); // 无此句会一秒后同时打印出123，因为await 等不到返回结果，for循环会立即执行。
                    }, 1000);
                });
            }
        }
        // print()

        /* 
        盒子内部点击打印false，外部点击打印true，
        如果是vue的话使用.self修饰符，只有点击事件本身才会触发
         */
        var box1 = document.getElementsByClassName('box1')[0];
        box1.addEventListener('click', function (event) {
            var isInside = event.target === box1; // 冒泡的时候触发事件检查点击的是否是div元素本身
            console.log(isInside ? '内部点击' : '外部点击');
        });

        /* 
        深拷贝
         */
        function deepClone(data) {
            return JSON.parse(JSON.stringify(data));
        }

        const i = [
            { id: '1', value: '1' },
            { id: '2', value: '2' },
            { id: '3', value: '3' },
            { id: '1-1', value: '1-1', pid: '1' },
            { id: '2-1', value: '2-1', pid: '2' },
            { id: '3-1', value: '3-1', pid: '3' },
            { id: '3-1-1', value: '3-1-1', pid: '3-1' },
        ];
        // 把含树结构的array数据转换为children层级形式的array返回
        function list2tree(list = [], id = 'id', pid = 'pid') {
            // 深拷贝
            const d_list = deepClone(list);

            // key，value字典
            const dic = {};
            for (const i of d_list) {
                dic[i[id]] = i;
            }

            // 树
            const tree = [];
            let index = 0;
            for (const i of d_list) {
                const p = dic[i[pid]];
                if (p) {
                    p.children = p.children ? [...p.children, i] : [i];
                    i.level = (p.level || 0) + 1;
                }
                else {
                    i.level = 0;
                    tree.push(i);
                }
            }
            return deepClone(tree);
        }

        // 组件
        const com = {}
        // 根据上述list2tree生成的数据返回树组件
        function loopComponent(list) {
            for (const i of list) {
                if (Array.isArray(i.children)) {
                    loopComponent(i.children)
                }
                return com
            }
        }

        // 给数字字符串添加千分位，注意小数点。
        // 原生实现 number.toLocaleString() // '123,456.789'
        function addThousandSeparator(num) {
            var numParts = String(num).split(".");
            numParts[0] = numParts[0].replace(/\B(?=(\d{3})+(?!\d))/g, ","); // 找到千分位
            return numParts.join(".");
        }
        // console.log(addThousandSeparator('6666666.6666666666'))

        // json扁平化
        let json = {
            name: 'John',
            age: 30,
            address: {
                city: 'New York',
                state: 'NY',
                zip: '10001',
                addressPlus: {
                    city: 'new london'
                }
            },
            hobbies: ['reading', 'traveling', 'music', ['test', 'test2', ['test3']]]
        };
        function flattenJSON(obj = {}, prefix = '') {
            let result = {}
            for (const key of Object.keys(obj)) {
                const newPrefix = prefix ? prefix + '_' + key : key
                if (typeof obj[key] === 'object' && obj !== null) {
                    result = Object.assign(result, flattenJSON2(obj[key], newPrefix))
                }
                else {
                    result[newPrefix] = obj[key]
                }
            }
            return result
        }
        // console.log(flattenJSON(json))

        /* 
        函数柯里化 实现
        (a,b,c)=>a+b+c
         */
        function curry(a) {
            return function (b) {
                return function (c) {
                    return a + b + c
                }
            }
        }
        // console.log(curry(1)(2)(3))


        // rgb转hex，三原色转十六进制颜色代码，如 255,255,255 => #ffffff
        function num2hex(n) {
            return n.toString(16).padStart(2, '0')
        }
        function rgb2hex(r, g, b) {
            return '#' + num2hex(r) + num2hex(g) + num2hex(b)
        }
        // console.log(rgb2hex(255, 255, 255))

        // 平方根 sqrt，返回向下取整的整数
        function mySqrt(x) {
            // 整数x的平方根一定是在1到x的范围内，采用二分法
            let left = 1,
                right = x;
            while (left <= right) {
                let mid = left + ((right - left) >> 1); // 右移一位相当于除以2取中间值，这样写防止溢出。
                // 判断mid的平方是否小于或等于x，如果mid的平方小于x
                if (mid <= x / mid) {
                    // 判断(mid+1)的平方是否大于x，如果(mid+1)的平方大于x，那么mid就是x的平方根
                    if (mid + 1 > x / (mid + 1)) {
                        return mid;
                    }
                    // 如果mid的平方小于x并且(mid+1)的平方小于x，那么x的平方根比mid大，接下来搜索从mid+1到x的范围
                    left = mid + 1;
                }
                else {
                    // 如果mid的平方大于x，则x的平方根小于mid，接下来搜索1到mid-1的范围
                    right = mid - 1;
                }
            }
            // 如果输入参数是0，left等于1而right等于0，就直接返回0
            return 0;
        };
        // console.log(mySqrt(6))

        /* 
        for循环与var，let
        */
        for (var index = 0; index < 3; index++) {
            setTimeout(() => {
                // console.log(index)
            }, 0);
        }
        // 3 3 3，因为var已经加完，按事件循环机制再执行console。

        for (let index = 0; index < 3; index++) {
            setTimeout(() => {
                // console.log(index)
            }, 0);
        }
        // 0 1 2，块级作用域for循环参数index有闭包保护。他们都是经过延时后一同调用，因为时间循环机制。

        /* 
        this 指向问题
        */
        const fun = {
            count: 'ahxc',
            show: function () {
                console.log('show', this.count)
            }
        }
        const exc = fun.show
        // exc() // undefined ，对象是window
        // fun.show() // ahxc ，对象是fun

        var value = 100
        function fn() {
            this.value++;
            return this.value;
        }
        var obj = {
            value: 1,
            fn
        }
        function delay(fn, delay) {
            return new Promise((resolve) => {
                setTimeout(() => {
                    resolve(fn());
                }
                    , delay);
            })
        }
        async function run() {
            var value = 10;
            try {
                console.log(1)
                const pms1 = delay(fn, 100);
                const pms2 = delay(obj.fn, 200);
                const value1 = await pms1;
                const value2 = await pms2;
                const value3 = await delay(fn.bind(obj), 300);
                console.log(value1, value2, value3)
            }
            catch (err) {
                console.error(err);
            }
        }
        // 耗时 500，pms1 pms2 是同步调用。

        /* 
        空瓶换汽水，3个空瓶换一瓶汽水，喝完可以加入剩余空瓶继续换，
        剩到两个空瓶可以和老板借一个空瓶换汽水到时喝完还给老板。换句话说，剩两个空瓶后可换一瓶汽水。
        */
        function bottle(n) {
            s = 0
            while (n >= 3) {
                n -= 2
                s += 1
            }
            if (n === 2) {
                s += 1
            }
            return s
        }
        // console.log(bottle(2))

        /* 
        n阶台阶问题，注意每次只能爬1和2阶台阶，n阶只能从n-1或n-2跳过来
        思路，所以n阶的跳法只能是n-1和n-2跳法的和，斐波那契数列去掉了0和1,0 1 1 2 3 5 8
        */
        function climbStairs(n) {
            if (n <= 2) return n
            let p = 1
            let q = 2
            for (let i = 3; i <= n; i++) {
                let temp = p
                p = q
                q = q + temp
            }
            return q
        }
        // console.log(climbStairs(2))

        /* 
        n阶台阶升级版，p，q是可以手动输入控制的，又有多少种解法，如3 1 2 输出3，p<=q=<n=<=100
        */
        function climbStairs(n, p, q) {

        }


        /* 
        验证有效ip地址
        */
        var validIPAddress = function (queryIP) {
            if (queryIP.includes('.')) {
                const list = queryIP.split('.')
                if (list.length !== 4) return 'Neither'
                for (const i of list) {
                    if (!checkip4(i)) {
                        return 'Neither'
                    }
                }
                return 'IPv4'
            }
            else {
                const list = queryIP.split(':')
                if (list.length !== 8) return 'Neither'
                for (const i of list) {
                    if (!checkip6(i)) {
                        return 'Neither'
                    }
                }
                return 'IPv6'
            }
        };

        function checkip4(str) {
            if (parseInt(str) > 255) {
                return false
            }
            // 如果是合法的转数字再转回去是不变的，有非法字符或前缀0或空串都不行，空串""''都为0
            if (String(parseInt(str)) !== str) {
                return false
            }
            return true
        }

        function checkip6(str) {
            if (str.length > 4) {
                return false
            }
            // 超出范围
            if (parseInt(str, 16) > parseInt('ffff', 16)) {
                return false
            }
            // ! 0dc8==dc8==DC8==dC8，统一转为小写，并用0补充空位；
            // 转为十进制然后回16进制排除非法字符如fGb2，g为非法字符，合理范围abcdef；
            if (parseInt(str, 16).toString(16).padStart(4, '0') !== str.padStart(4, '0').toLowerCase()) {
                return false
            }
            return true
        }
        // console.log(validIPAddress("2001:0db8:85a3:00000:0:8A2E:0370:7334"))

        /* 
        前k个高频词汇
        注意：如果是相同频率的单词，按照字典abc的顺序排序
        */
        function topKFrequent(params) {
            const dic = {}
            for (const i of words) {
                if (dic[i]) {
                    dic[i] += 1
                }
                else {
                    dic[i] = 1
                }
            }

            const list = Object.keys(dic).sort((a, b) => {
                if (dic[a] === dic[b]) {
                    return a.localeCompare(b) // 字母顺序
                }
                return dic[b] - dic[a]
            })
            return list.slice(0, k)
        }

        /* 
        反转句子
        hello word =》word hello
        注意首尾空格和空元素
         */
        function reverseWords(s) {
            const list = s.split(' ')
            return list.filter((item) => item).reverse().join(' ')
        };
    </script>
</body>

</html>